Test
Scanner [32m.[0m[<NEWLINE>, 2]
[identifier, 2]
[12345, 2]
[<NEWLINE>, 3]
['a', 3]
['	', 3]
["abc
", 3]
[<NEWLINE>, 4]
[module, 4]
[import, 4]
[as, 4]
[<NEWLINE>, 5]
[type, 5]
[unit, 5]
[bool, 5]
[int, 5]
[char, 5]
[float, 5]
[string, 5]
[<NEWLINE>, 6]
[let, 6]
[fn, 6]
[if, 6]
[then, 6]
[else, 6]
[match, 6]
[<NEWLINE>, 7]
[=, 7]
[==, 7]
[!=, 7]
[<, 7]
[<=, 7]
[>, 7]
[>=, 7]
[<NEWLINE>, 8]
[-, 8]
[+, 8]
[/, 8]
[*, 8]
[%, 8]
[<NEWLINE>, 9]
[!, 9]
[(), 9]
[|, 9]
[||, 9]
[&&, 9]
[<NEWLINE>, 10]
[->, 10]
[(, 10]
[), 10]
[[, 10]
[], 10]
[{, 10]
[}, 10]
[<NEWLINE>, 11]
[_, 11]
[,, 11]
[[], 11]
[:, 11]
[;, 11]
[<NEWLINE>, 12]
[<EOF>, 12]
[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m
Parser text    > 'a'
parsed  > 'a'
expected> 'a'
[32m.[0mtext    > "abc"
parsed  > "abc"
expected> "abc"
[32m.[0mtext    > 12
parsed  > 12
expected> 12
[32m.[0mtext    > 300 + 12
parsed  > (300 + 12)
expected> (300 + 12)
[32m.[0mtext    > 300 * 12 + 3
parsed  > ((300 * 12) + 3)
expected> ((300 * 12) + 3)
[32m.[0mtext    > 300 * (12 + 3)
parsed  > (300 * (12 + 3))
expected> (300 * (12 + 3))
[32m.[0mtext    > 1 / 2 < 3 * 4
parsed  > ((1 / 2) < (3 * 4))
expected> ((1 / 2) < (3 * 4))
[32m.[0mtext    > 2 * -(1 + 2)
parsed  > (2 * (-(1 + 2)))
expected> (2 * (-(1 + 2)))
[32m.[0mtext    > 5 % 2
parsed  > (5 % 2)
expected> (5 % 2)
[32m.[0mtext    > a && b
parsed  > (a && b)
expected> (a && b)
[32m.[0mtext    > a || b
parsed  > (a || b)
expected> (a || b)
[32m.[0mtext    > !(x < y)
parsed  > (!(x < y))
expected> (!(x < y))
[32m.[0mtext    > 1 <= 2
parsed  > (1 <= 2)
expected> (1 <= 2)
[32m.[0mtext    > 1 > 2
parsed  > (1 > 2)
expected> (1 > 2)
[32m.[0mtext    > 1 >= 2
parsed  > (1 >= 2)
expected> (1 >= 2)
[32m.[0mtext    > 1 == 2
parsed  > (1 == 2)
expected> (1 == 2)
[32m.[0mtext    > 1 != 2
parsed  > (1 != 2)
expected> (1 != 2)
[32m.[0mtext    > fn x -> x + 1
parsed  > (fn x -> (x + 1))
expected> (fn x -> (x + 1))
[32m.[0mtext    > f 3
parsed  > (f 3)
expected> (f 3)
[32m.[0mtext    > -(f 3)
parsed  > (-(f 3))
expected> (-(f 3))
[32m.[0mtext    > f (-3)
parsed  > (f (-3))
expected> (f (-3))
[32m.[0mtext    > f -3
parsed  > (f - 3)
expected> (f - 3)
[32m.[0mtext    > fn () -> 1
parsed  > (fn () -> 1)
expected> (fn () -> 1)
[32m.[0mtext    > (fn x -> x + 1) (300 * (12 + 3))
parsed  > ((fn x -> (x + 1)) (300 * (12 + 3)))
expected> ((fn x -> (x + 1)) (300 * (12 + 3)))
[32m.[0mtext    > let fact = fn n -> if n < 1 then 1 else n * fact (n - 1)
parsed  > (let fact = (fn n -> (if (n < 1) then 1 else (n * (fact (n - 1))))))
expected> (let fact = (fn n -> (if (n < 1) then 1 else (n * (fact (n - 1))))))
[32m.[0mtext    > {}
parsed  > {}
expected> {}
[32m.[0mtext    > {1; 2; }
parsed  > {1; 2; }
expected> {1; 2; }
[32m.[0mtext    > {1; 2; 3}
parsed  > {1; 2; 3; }
expected> {1; 2; 3; }
[32m.[0mtext    > let fact = fn n -> if n < 1 then 1 else n * fact (n - 1)
parsed  > (let fact = (fn n -> (if (n < 1) then 1 else (n * (fact (n - 1))))))
expected> (let fact = (fn n -> (if (n < 1) then 1 else (n * (fact (n - 1))))))
[32m.[0mtext    > 1+2+3
parsed  > ((1 + 2) + 3)
expected> ((1 + 2) + 3)
[32m.[0mtext    > f 1 2
parsed  > ((f 1) 2)
expected> ((f 1) 2)
[32m.[0mtext    > f 1 2 3
parsed  > (((f 1) 2) 3)
expected> (((f 1) 2) 3)
[32m.[0mtext    > 1:2:3:[]
parsed  > (1 : (2 : (3 : [])))
expected> (1 : (2 : (3 : [])))
[32m.[0mtext    > [1,2,3]
parsed  > (1 : (2 : (3 : [])))
expected> (1 : (2 : (3 : [])))
[32m.[0mtext    > (1)
parsed  > 1
expected> 1
[32m.[0mtext    > true
parsed  > true
expected> true
[32m.[0mtext    > false
parsed  > false
expected> false
[32m.[0mtext    > fun one () = 1
parsed  > (letrec one (fn () -> 1))
expected> (letrec one (fn () -> 1))
[32m.[0mtext    > fun fact n = if n < 1 then 1 else n * fact (n-1)
parsed  > (letrec fact (fn n -> (if (n < 1) then 1 else (n * (fact (n - 1))))))
expected> (letrec fact (fn n -> (if (n < 1) then 1 else (n * (fact (n - 1))))))
[32m.[0mtext    > module List
parsed  > module List
expected> module List
[32m.[0mtext    > import Array
parsed  > import Array
expected> import Array
[32m.[0mtext    > import Array as A
parsed  > import Array as A
expected> import Array as A
[32m.[0mtext    > Array.length
parsed  > Array.length
expected> Array.length
[32m.[0mtext    > (1)
parsed  > 1
expected> 1
[32m.[0mtext    > (1,2)
parsed  > (1, 2)
expected> (1, 2)
[32m.[0mtext    > (1,2,3)
parsed  > (1, 2, 3)
expected> (1, 2, 3)
[32m.[0mtext    > match x { 0 -> 'a' | 1 -> 'b' | 2 -> 'c' }
parsed  > (match x { | 0 -> 'a' | 1 -> 'b' | 2 -> 'c'})
expected> (match x { | 0 -> 'a' | 1 -> 'b' | 2 -> 'c'})
[32m.[0mtext    > match x { [] -> 0 | _:xs -> 1 }
parsed  > (match x { | [] -> 0 | _ | xs -> 1})
expected> (match x { | [] -> 0 | _ | xs -> 1})
[32m.[0mtext    > match 1 { x -> x }
parsed  > (match 1 { | x -> x})
expected> (match 1 { | x -> x})
[32m.[0mtext    > match n { 1 | 2 | 3 -> 0 | 4 -> 1 }
parsed  > (match n { | 1:2:3 -> 0 | 4 -> 1})
expected> (match n { | 1:2:3 -> 0 | 4 -> 1})
[32m.[0mtext    > match n { _ as a -> 1}
parsed  > (match n { | (_) as a -> 1})
expected> (match n { | (_) as a -> 1})
[32m.[0mtext    > match n { [a,b,c] -> 3 }
parsed  > (match n { | [ a b c] -> 3})
expected> (match n { | [ a b c] -> 3})
[32m.[0mtext    > match n { (1) -> 2 }
parsed  > (match n { | 1 -> 2})
expected> (match n { | 1 -> 2})
[32m.[0mtext    > match n { (1, 'c') -> 3 }
parsed  > (match n { |  1 'c' -> 3})
expected> (match n { |  1 'c' -> 3})
[32m.[0mtext    > match n { (_,_,x) -> x }
parsed  > (match n { |  _ _ x -> x})
expected> (match n { |  _ _ x -> x})
[32m.[0m
Eval text> 'a'
T* infer 'a'
T* infer 'a' result = char
'a'
evaluated> a : char
expected > a
[32m.[0mtext> "abc"
T* infer "abc"
T* infer "abc" result = string
"abc"
evaluated> abc : string
expected > abc
[32m.[0mtext> 12
T* infer 12
T* infer 12 result = int
12
evaluated> 12 : int
expected > 12
[32m.[0mtext> 300 + 12
T* infer (300 + 12)
T* infer 300
T* infer 300 result = int
T* infer 12
T* infer 12 result = int
T* infer_binary + int int
T* unify int int
T* after unify int int
T* infer (300 + 12) result = int
(300 + 12)
evaluated> 312 : int
expected > 312
[32m.[0mtext> 300 * 12 + 3
T* infer ((300 * 12) + 3)
T* infer (300 * 12)
T* infer 300
T* infer 300 result = int
T* infer 12
T* infer 12 result = int
T* infer_binary * int int
T* unify int int
T* infer (300 * 12) result = int
T* infer 3
T* infer 3 result = int
T* infer_binary + int int
T* unify int int
T* after unify int int
T* infer ((300 * 12) + 3) result = int
((300 * 12) + 3)
evaluated> 3603 : int
expected > 3603
[32m.[0mtext> 300 * (12 + 3)
T* infer (300 * (12 + 3))
T* infer 300
T* infer 300 result = int
T* infer (12 + 3)
T* infer 12
T* infer 12 result = int
T* infer 3
T* infer 3 result = int
T* infer_binary + int int
T* unify int int
T* after unify int int
T* infer (12 + 3) result = int
T* infer_binary * int int
T* unify int int
T* infer (300 * (12 + 3)) result = int
(300 * (12 + 3))
evaluated> 4500 : int
expected > 4500
[32m.[0mtext> 300 / (12 - 3)
T* infer (300 / (12 - 3))
T* infer 300
T* infer 300 result = int
T* infer (12 - 3)
T* infer 12
T* infer 12 result = int
T* infer 3
T* infer 3 result = int
T* infer_binary - int int
T* unify int int
T* infer (12 - 3) result = int
T* infer_binary / int int
T* unify int int
T* infer (300 / (12 - 3)) result = int
(300 / (12 - 3))
evaluated> 33 : int
expected > 33
[32m.[0mtext> 300 % (12 - 3)
T* infer (300 % (12 - 3))
T* infer 300
T* infer 300 result = int
T* infer (12 - 3)
T* infer 12
T* infer 12 result = int
T* infer 3
T* infer 3 result = int
T* infer_binary - int int
T* unify int int
T* infer (12 - 3) result = int
T* infer_binary % int int
T* unify int int
T* infer (300 % (12 - 3)) result = int
(300 % (12 - 3))
evaluated> 3 : int
expected > 3
[32m.[0mtext> 1 < 2
T* infer (1 < 2)
T* infer 1
T* infer 1 result = int
T* infer 2
T* infer 2 result = int
T* infer_binary < int int
T* unify int int
T* infer (1 < 2) result = bool
(1 < 2)
evaluated> true : bool
expected > true
[32m.[0mtext> 1 <= 1
T* infer (1 <= 1)
T* infer 1
T* infer 1 result = int
T* infer 1
T* infer 1 result = int
T* infer_binary <= int int
T* unify int int
T* infer (1 <= 1) result = bool
(1 <= 1)
evaluated> true : bool
expected > true
[32m.[0mtext> 1 > 2
T* infer (1 > 2)
T* infer 1
T* infer 1 result = int
T* infer 2
T* infer 2 result = int
T* infer_binary > int int
T* unify int int
T* infer (1 > 2) result = bool
(1 > 2)
evaluated> false : bool
expected > false
[32m.[0mtext> 2 >= 2
T* infer (2 >= 2)
T* infer 2
T* infer 2 result = int
T* infer 2
T* infer 2 result = int
T* infer_binary >= int int
T* unify int int
T* infer (2 >= 2) result = bool
(2 >= 2)
evaluated> true : bool
expected > true
[32m.[0mtext> 2 == 2
T* infer (2 == 2)
T* infer 2
T* infer 2 result = int
T* infer 2
T* infer 2 result = int
T* infer_binary == int int
T* unify int int
T* infer (2 == 2) result = bool
(2 == 2)
evaluated> true : bool
expected > true
[32m.[0mtext> 2 == 1
T* infer (2 == 1)
T* infer 2
T* infer 2 result = int
T* infer 1
T* infer 1 result = int
T* infer_binary == int int
T* unify int int
T* infer (2 == 1) result = bool
(2 == 1)
evaluated> false : bool
expected > false
[32m.[0mtext> 2 != 1
T* infer (2 != 1)
T* infer 2
T* infer 2 result = int
T* infer 1
T* infer 1 result = int
T* infer_binary != int int
T* unify int int
T* infer (2 != 1) result = bool
(2 != 1)
evaluated> true : bool
expected > true
[32m.[0mtext> 2 != 2
T* infer (2 != 2)
T* infer 2
T* infer 2 result = int
T* infer 2
T* infer 2 result = int
T* infer_binary != int int
T* unify int int
T* infer (2 != 2) result = bool
(2 != 2)
evaluated> false : bool
expected > false
[32m.[0mtext> 'a' == 'a'
T* infer ('a' == 'a')
T* infer 'a'
T* infer 'a' result = char
T* infer 'a'
T* infer 'a' result = char
T* infer_binary == char char
T* unify char char
T* infer ('a' == 'a') result = bool
('a' == 'a')
evaluated> true : bool
expected > true
[32m.[0mtext> 'a' == 'b'
T* infer ('a' == 'b')
T* infer 'a'
T* infer 'a' result = char
T* infer 'b'
T* infer 'b' result = char
T* infer_binary == char char
T* unify char char
T* infer ('a' == 'b') result = bool
('a' == 'b')
evaluated> false : bool
expected > false
[32m.[0mtext> 'a' != 'a'
T* infer ('a' != 'a')
T* infer 'a'
T* infer 'a' result = char
T* infer 'a'
T* infer 'a' result = char
T* infer_binary != char char
T* unify char char
T* infer ('a' != 'a') result = bool
('a' != 'a')
evaluated> false : bool
expected > false
[32m.[0mtext> 'a' != 'b'
T* infer ('a' != 'b')
T* infer 'a'
T* infer 'a' result = char
T* infer 'b'
T* infer 'b' result = char
T* infer_binary != char char
T* unify char char
T* infer ('a' != 'b') result = bool
('a' != 'b')
evaluated> true : bool
expected > true
[32m.[0mtext> 'a' < 'b'
T* infer ('a' < 'b')
T* infer 'a'
T* infer 'a' result = char
T* infer 'b'
T* infer 'b' result = char
T* infer_binary < char char
T* unify char char
T* infer ('a' < 'b') result = bool
('a' < 'b')
evaluated> true : bool
expected > true
[32m.[0mtext> 'b' < 'a'
T* infer ('b' < 'a')
T* infer 'b'
T* infer 'b' result = char
T* infer 'a'
T* infer 'a' result = char
T* infer_binary < char char
T* unify char char
T* infer ('b' < 'a') result = bool
('b' < 'a')
evaluated> false : bool
expected > false
[32m.[0mtext> 'a' <= 'a'
T* infer ('a' <= 'a')
T* infer 'a'
T* infer 'a' result = char
T* infer 'a'
T* infer 'a' result = char
T* infer_binary <= char char
T* unify char char
T* infer ('a' <= 'a') result = bool
('a' <= 'a')
evaluated> true : bool
expected > true
[32m.[0mtext> 'b' <= 'a'
T* infer ('b' <= 'a')
T* infer 'b'
T* infer 'b' result = char
T* infer 'a'
T* infer 'a' result = char
T* infer_binary <= char char
T* unify char char
T* infer ('b' <= 'a') result = bool
('b' <= 'a')
evaluated> false : bool
expected > false
[32m.[0mtext> 'a' > 'b'
T* infer ('a' > 'b')
T* infer 'a'
T* infer 'a' result = char
T* infer 'b'
T* infer 'b' result = char
T* infer_binary > char char
T* unify char char
T* infer ('a' > 'b') result = bool
('a' > 'b')
evaluated> false : bool
expected > false
[32m.[0mtext> 'b' > 'a'
T* infer ('b' > 'a')
T* infer 'b'
T* infer 'b' result = char
T* infer 'a'
T* infer 'a' result = char
T* infer_binary > char char
T* unify char char
T* infer ('b' > 'a') result = bool
('b' > 'a')
evaluated> true : bool
expected > true
[32m.[0mtext> 'a' >= 'b'
T* infer ('a' >= 'b')
T* infer 'a'
T* infer 'a' result = char
T* infer 'b'
T* infer 'b' result = char
T* infer_binary >= char char
T* unify char char
T* infer ('a' >= 'b') result = bool
('a' >= 'b')
evaluated> false : bool
expected > false
[32m.[0mtext> 'a' >= 'a'
T* infer ('a' >= 'a')
T* infer 'a'
T* infer 'a' result = char
T* infer 'a'
T* infer 'a' result = char
T* infer_binary >= char char
T* unify char char
T* infer ('a' >= 'a') result = bool
('a' >= 'a')
evaluated> true : bool
expected > true
[32m.[0mtext> "abc" + "def"
T* infer ("abc" + "def")
T* infer "abc"
T* infer "abc" result = string
T* infer "def"
T* infer "def" result = string
T* infer_binary + string string
T* unify string string
T* after unify string string
T* infer ("abc" + "def") result = string
("abc" + "def")
evaluated> abcdef : string
expected > abcdef
[32m.[0mtext> "abc" == "abc"
T* infer ("abc" == "abc")
T* infer "abc"
T* infer "abc" result = string
T* infer "abc"
T* infer "abc" result = string
T* infer_binary == string string
T* unify string string
T* infer ("abc" == "abc") result = bool
("abc" == "abc")
evaluated> true : bool
expected > true
[32m.[0mtext> "abc" == "def"
T* infer ("abc" == "def")
T* infer "abc"
T* infer "abc" result = string
T* infer "def"
T* infer "def" result = string
T* infer_binary == string string
T* unify string string
T* infer ("abc" == "def") result = bool
("abc" == "def")
evaluated> false : bool
expected > false
[32m.[0mtext> "abc" != "abc"
T* infer ("abc" != "abc")
T* infer "abc"
T* infer "abc" result = string
T* infer "abc"
T* infer "abc" result = string
T* infer_binary != string string
T* unify string string
T* infer ("abc" != "abc") result = bool
("abc" != "abc")
evaluated> false : bool
expected > false
[32m.[0mtext> "abc" != "def"
T* infer ("abc" != "def")
T* infer "abc"
T* infer "abc" result = string
T* infer "def"
T* infer "def" result = string
T* infer_binary != string string
T* unify string string
T* infer ("abc" != "def") result = bool
("abc" != "def")
evaluated> true : bool
expected > true
[32m.[0mtext> "abc" < "def"
T* infer ("abc" < "def")
T* infer "abc"
T* infer "abc" result = string
T* infer "def"
T* infer "def" result = string
T* infer_binary < string string
T* unify string string
T* infer ("abc" < "def") result = bool
("abc" < "def")
evaluated> true : bool
expected > true
[32m.[0mtext> "abc" > "def"
T* infer ("abc" > "def")
T* infer "abc"
T* infer "abc" result = string
T* infer "def"
T* infer "def" result = string
T* infer_binary > string string
T* unify string string
T* infer ("abc" > "def") result = bool
("abc" > "def")
evaluated> false : bool
expected > false
[32m.[0mtext> 1 > 2 || 2 > 1
T* infer ((1 > 2) || (2 > 1))
T* infer (1 > 2)
T* infer 1
T* infer 1 result = int
T* infer 2
T* infer 2 result = int
T* infer_binary > int int
T* unify int int
T* infer (1 > 2) result = bool
T* infer (2 > 1)
T* infer 2
T* infer 2 result = int
T* infer 1
T* infer 1 result = int
T* infer_binary > int int
T* unify int int
T* infer (2 > 1) result = bool
T* infer_binary || bool bool
T* unify bool bool
T* unify bool bool
T* infer ((1 > 2) || (2 > 1)) result = bool
((1 > 2) || (2 > 1))
evaluated> true : bool
expected > true
[32m.[0mtext> 1 < 2 && 2 < 1
T* infer ((1 < 2) && (2 < 1))
T* infer (1 < 2)
T* infer 1
T* infer 1 result = int
T* infer 2
T* infer 2 result = int
T* infer_binary < int int
T* unify int int
T* infer (1 < 2) result = bool
T* infer (2 < 1)
T* infer 2
T* infer 2 result = int
T* infer 1
T* infer 1 result = int
T* infer_binary < int int
T* unify int int
T* infer (2 < 1) result = bool
T* infer_binary && bool bool
T* unify bool bool
T* unify bool bool
T* infer ((1 < 2) && (2 < 1)) result = bool
((1 < 2) && (2 < 1))
evaluated> false : bool
expected > false
[32m.[0mtext> -5
T* infer (-5)
T* infer 5
T* infer 5 result = int
T* unify int int
T* infer (-5) result = int
(-5)
evaluated> -5 : int
expected > -5
[32m.[0mtext> !true
T* infer (!true)
T* infer true
T* infer true result = bool
T* unify bool bool
T* infer (!true) result = bool
(!true)
evaluated> false : bool
expected > false
[32m.[0mtext> !false
T* infer (!false)
T* infer false
T* infer false result = bool
T* unify bool bool
T* infer (!false) result = bool
(!false)
evaluated> true : bool
expected > true
[32m.[0mtext> 1:[2,3]
T* infer (1 : (2 : (3 : [])))
T* infer 1
T* infer 1 result = int
T* infer (2 : (3 : []))
T* infer 2
T* infer 2 result = int
T* infer (3 : [])
T* infer 3
T* infer 3 result = int
T* infer []
T* infer [] result = ['h]
T* infer_binary : int ['a]
T* unify [int] ['a]
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (3 : []) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (2 : (3 : [])) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (1 : (2 : (3 : []))) result = [int]
(1 : (2 : (3 : [])))
evaluated> [1, 2, 3] : [int]
expected > [1, 2, 3]
[32m.[0mtext> 1:2:[3]
T* infer (1 : (2 : (3 : [])))
T* infer 1
T* infer 1 result = int
T* infer (2 : (3 : []))
T* infer 2
T* infer 2 result = int
T* infer (3 : [])
T* infer 3
T* infer 3 result = int
T* infer []
T* infer [] result = ['i]
T* infer_binary : int ['a]
T* unify [int] ['a]
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (3 : []) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (2 : (3 : [])) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (1 : (2 : (3 : []))) result = [int]
(1 : (2 : (3 : [])))
evaluated> [1, 2, 3] : [int]
expected > [1, 2, 3]
[32m.[0mtext> [1,2,3]
T* infer (1 : (2 : (3 : [])))
T* infer 1
T* infer 1 result = int
T* infer (2 : (3 : []))
T* infer 2
T* infer 2 result = int
T* infer (3 : [])
T* infer 3
T* infer 3 result = int
T* infer []
T* infer [] result = ['j]
T* infer_binary : int ['a]
T* unify [int] ['a]
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (3 : []) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (2 : (3 : [])) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (1 : (2 : (3 : []))) result = [int]
(1 : (2 : (3 : [])))
evaluated> [1, 2, 3] : [int]
expected > [1, 2, 3]
[32m.[0mtext> [1,2,3] == 1:[2,3]
T* infer ((1 : (2 : (3 : []))) == (1 : (2 : (3 : []))))
T* infer (1 : (2 : (3 : [])))
T* infer 1
T* infer 1 result = int
T* infer (2 : (3 : []))
T* infer 2
T* infer 2 result = int
T* infer (3 : [])
T* infer 3
T* infer 3 result = int
T* infer []
T* infer [] result = ['k]
T* infer_binary : int ['a]
T* unify [int] ['a]
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (3 : []) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (2 : (3 : [])) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (1 : (2 : (3 : []))) result = [int]
T* infer (1 : (2 : (3 : [])))
T* infer 1
T* infer 1 result = int
T* infer (2 : (3 : []))
T* infer 2
T* infer 2 result = int
T* infer (3 : [])
T* infer 3
T* infer 3 result = int
T* infer []
T* infer [] result = ['l]
T* infer_binary : int ['a]
T* unify [int] ['a]
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (3 : []) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (2 : (3 : [])) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (1 : (2 : (3 : []))) result = [int]
T* infer_binary == [int] [int]
T* unify [int] [int]
T* unify int int
T* infer ((1 : (2 : (3 : []))) == (1 : (2 : (3 : [])))) result = bool
((1 : (2 : (3 : []))) == (1 : (2 : (3 : []))))
evaluated> true : bool
expected > true
[32m.[0mtext> [1,2,3] == 1:[2,3,4]
T* infer ((1 : (2 : (3 : []))) == (1 : (2 : (3 : (4 : [])))))
T* infer (1 : (2 : (3 : [])))
T* infer 1
T* infer 1 result = int
T* infer (2 : (3 : []))
T* infer 2
T* infer 2 result = int
T* infer (3 : [])
T* infer 3
T* infer 3 result = int
T* infer []
T* infer [] result = ['m]
T* infer_binary : int ['a]
T* unify [int] ['a]
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (3 : []) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (2 : (3 : [])) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (1 : (2 : (3 : []))) result = [int]
T* infer (1 : (2 : (3 : (4 : []))))
T* infer 1
T* infer 1 result = int
T* infer (2 : (3 : (4 : [])))
T* infer 2
T* infer 2 result = int
T* infer (3 : (4 : []))
T* infer 3
T* infer 3 result = int
T* infer (4 : [])
T* infer 4
T* infer 4 result = int
T* infer []
T* infer [] result = ['n]
T* infer_binary : int ['a]
T* unify [int] ['a]
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (4 : []) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (3 : (4 : [])) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (2 : (3 : (4 : []))) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (1 : (2 : (3 : (4 : [])))) result = [int]
T* infer_binary == [int] [int]
T* unify [int] [int]
T* unify int int
T* infer ((1 : (2 : (3 : []))) == (1 : (2 : (3 : (4 : []))))) result = bool
((1 : (2 : (3 : []))) == (1 : (2 : (3 : (4 : [])))))
evaluated> false : bool
expected > false
[32m.[0mtext> let x = 1
T* infer (let x = 1)
T* infer let x = 1
T* infer 1
T* infer 1 result = int
T* after infer int
T* poly type = { vars:[] body:int}
T* infer (let x = 1) result = unit
(let x = 1)
evaluated> () : unit
expected > ()
[32m.[0mtext> x
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:int}
T* infer Ident x ... ts alpha = { vars:[] body:int}
T* infer x result = int
x
evaluated> 1 : int
expected > 1
[32m.[0mtext> let f = fn () -> 5
T* infer (let f = (fn () -> 5))
T* infer let f = (fn () -> 5)
T* infer (fn () -> 5)
T* infer 5
T* infer 5 result = int
T* infer (fn () -> 5) result = unit -> int
T* after infer unit -> int
T* poly type = { vars:[] body:unit -> int}
T* infer (let f = (fn () -> 5)) result = unit
(let f = (fn () -> 5))
evaluated> () : unit
expected > ()
[32m.[0mtext> f ()
T* infer (f ())
T* infer f
T* infer Ident f
T* infer Ident f ... type schema is { vars:[] body:unit -> int}
T* infer Ident f ... ts alpha = { vars:[] body:unit -> int}
T* infer f result = unit -> int
T* infer ()
T* infer () result = unit
T* unify unit -> int unit -> 'a
T* unify unit unit
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (f ()) result = int!
(f ())
evaluated> 5 : int
expected > 5
[32m.[0mtext> let g = fn _ -> 8
T* infer (let g = (fn _ -> 8))
T* infer let g = (fn _ -> 8)
T* infer (fn _ -> 8)
T* infer 8
T* infer 8 result = int
T* infer (fn _ -> 8) result = 'p -> int
T* after infer 'p -> int
T* poly type = { vars:[15] body:'p -> int}
T* infer (let g = (fn _ -> 8)) result = unit
(let g = (fn _ -> 8))
evaluated> () : unit
expected > ()
[32m.[0mtext> g 3
T* infer (g 3)
T* infer g
T* infer Ident g
T* infer Ident g ... type schema is { vars:[15] body:'p -> int}
T* infer Ident g ... ts alpha = { vars:[16] body:'q -> int}
T* infer g result = 'q -> int
T* infer 3
T* infer 3 result = int
T* unify 'a -> int int -> 'a
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (g 3) result = int!
(g 3)
evaluated> 8 : int
expected > 8
[32m.[0mtext> let a = fn x -> x + 1
T* infer (let a = (fn x -> (x + 1)))
T* infer let a = (fn x -> (x + 1))
T* infer (fn x -> (x + 1))
T* infer Fn (x, (x + 1))
T* infer x ... arg type = 's
T* infer x ... arg ts = { vars:[] body:'s}
T* infer (x + 1)
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'s}
T* infer Ident x ... ts alpha = { vars:[] body:'s}
T* infer x result = 's
T* infer 1
T* infer 1 result = int
T* infer_binary + 'a int
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* after unify int int
T* infer (x + 1) result = int!
T* after infer int!
T* infer (fn x -> (x + 1)) result = int! -> int!
T* after infer int! -> int!
T* poly type = { vars:[] body:int -> int}
T* infer (let a = (fn x -> (x + 1))) result = unit
(let a = (fn x -> (x + 1)))
evaluated> () : unit
expected > ()
[32m.[0mtext> a 4
T* infer (a 4)
T* infer a
T* infer Ident a
T* infer Ident a ... type schema is { vars:[] body:int -> int}
T* infer Ident a ... ts alpha = { vars:[] body:int -> int}
T* infer a result = int -> int
T* infer 4
T* infer 4 result = int
T* unify int -> int int -> 'a
T* unify int int
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (a 4) result = int!
(a 4)
evaluated> 5 : int
expected > 5
[32m.[0mtext> let add = fn x -> fn y -> x + y
T* infer (let add = (fn x -> (fn y -> (x + y))))
T* infer let add = (fn x -> (fn y -> (x + y)))
T* infer (fn x -> (fn y -> (x + y)))
T* infer Fn (x, (fn y -> (x + y)))
T* infer x ... arg type = 'u
T* infer x ... arg ts = { vars:[] body:'u}
T* infer (fn y -> (x + y))
T* infer Fn (y, (x + y))
T* infer y ... arg type = 'v
T* infer y ... arg ts = { vars:[] body:'v}
T* infer (x + y)
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'u}
T* infer Ident x ... ts alpha = { vars:[] body:'u}
T* infer x result = 'u
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:'v}
T* infer Ident y ... ts alpha = { vars:[] body:'v}
T* infer y result = 'v
T* infer_binary + 'a 'a
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* after unify 'a 'a
T* infer (x + y) result = 'v!
T* after infer 'v!
T* infer (fn y -> (x + y)) result = 'v -> 'v!
T* after infer 'v -> 'v!
T* infer (fn x -> (fn y -> (x + y))) result = 'v! -> 'v -> 'v!
T* after infer 'v! -> 'v -> 'v!
T* poly type = { vars:[21] body:'v -> 'v -> 'v}
T* infer (let add = (fn x -> (fn y -> (x + y)))) result = unit
(let add = (fn x -> (fn y -> (x + y))))
evaluated> () : unit
expected > ()
[32m.[0mtext> add 1 2
T* infer ((add 1) 2)
T* infer (add 1)
T* infer add
T* infer Ident add
T* infer Ident add ... type schema is { vars:[21] body:'v -> 'v -> 'v}
T* infer Ident add ... ts alpha = { vars:[22] body:'w -> 'w -> 'w}
T* infer add result = 'w -> 'w -> 'w
T* infer 1
T* infer 1 result = int
T* unify 'a -> 'a -> 'a int -> 'a
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify int -> int 'a
T* unify result 'a ... 
T* ... int -> int
T* infer (add 1) result = int! -> int!!
T* infer 2
T* infer 2 result = int
T* unify int -> int int -> 'a
T* unify int -> int int -> 'a
T* unify int int
T* unify int int
T* unify int 'a
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer ((add 1) 2) result = int!
((add 1) 2)
evaluated> 3 : int
expected > 3
[32m.[0mtext> let add5 = add 5
T* infer (let add5 = (add 5))
T* infer let add5 = (add 5)
T* infer (add 5)
T* infer add
T* infer Ident add
T* infer Ident add ... type schema is { vars:[21] body:'v -> 'v -> 'v}
T* infer Ident add ... ts alpha = { vars:[25] body:'z -> 'z -> 'z}
T* infer add result = 'z -> 'z -> 'z
T* infer 5
T* infer 5 result = int
T* unify 'a -> 'a -> 'a int -> 'a
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify int -> int 'a
T* unify result 'a ... 
T* ... int -> int
T* infer (add 5) result = int! -> int!!
T* after infer int! -> int!!
T* poly type = { vars:[] body:int -> int}
T* infer (let add5 = (add 5)) result = unit
(let add5 = (add 5))
evaluated> () : unit
expected > ()
[32m.[0mtext> add5 3
T* infer (add5 3)
T* infer add5
T* infer Ident add5
T* infer Ident add5 ... type schema is { vars:[] body:int -> int}
T* infer Ident add5 ... ts alpha = { vars:[] body:int -> int}
T* infer add5 result = int -> int
T* infer 3
T* infer 3 result = int
T* unify int -> int int -> 'a
T* unify int int
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (add5 3) result = int!
(add5 3)
evaluated> 8 : int
expected > 8
[32m.[0mtext> fun foo x = x + 2
T* infer (letrec foo (fn x -> (x + 2)))
T* infer letrec foo = (fn x -> (x + 2))
T* infer foo type_schema = { vars:[] body:'28}
T* infer (fn x -> (x + 2))
T* infer Fn (x, (x + 2))
T* infer x ... arg type = '29
T* infer x ... arg ts = { vars:[] body:'29}
T* infer (x + 2)
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'29}
T* infer Ident x ... ts alpha = { vars:[] body:'29}
T* infer x result = '29
T* infer 2
T* infer 2 result = int
T* infer_binary + 'a int
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* after unify int int
T* infer (x + 2) result = int!
T* after infer int!
T* infer (fn x -> (x + 2)) result = int! -> int!
T* after infer int! -> int!
T* infer poly type = { vars:[] body:int -> int}
T* infer (letrec foo (fn x -> (x + 2))) result = unit
(letrec foo (fn x -> (x + 2)))
evaluated> () : unit
expected > ()
[32m.[0mtext> foo 4
T* infer (foo 4)
T* infer foo
T* infer Ident foo
T* infer Ident foo ... type schema is { vars:[] body:int -> int}
T* infer Ident foo ... ts alpha = { vars:[] body:int -> int}
T* infer foo result = int -> int
T* infer 4
T* infer 4 result = int
T* unify int -> int int -> 'a
T* unify int int
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (foo 4) result = int!
(foo 4)
evaluated> 6 : int
expected > 6
[32m.[0mtext> fun fact n = if n < 1 then 1 else n * fact (n-1)
T* infer (letrec fact (fn n -> (if (n < 1) then 1 else (n * (fact (n - 1))))))
T* infer letrec fact = (fn n -> (if (n < 1) then 1 else (n * (fact (n - 1)))))
T* infer fact type_schema = { vars:[] body:'31}
T* infer (fn n -> (if (n < 1) then 1 else (n * (fact (n - 1)))))
T* infer Fn (n, (if (n < 1) then 1 else (n * (fact (n - 1)))))
T* infer n ... arg type = '32
T* infer n ... arg ts = { vars:[] body:'32}
T* infer (if (n < 1) then 1 else (n * (fact (n - 1))))
T* infer If (n < 1) then 1 else (n * (fact (n - 1)))
T* infer (n < 1)
T* infer n
T* infer Ident n
T* infer Ident n ... type schema is { vars:[] body:'32}
T* infer Ident n ... ts alpha = { vars:[] body:'32}
T* infer n result = '32
T* infer 1
T* infer 1 result = int
T* infer_binary < 'a int
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* infer (n < 1) result = bool
T* unify bool bool
T* infer 1
T* infer 1 result = int
T* infer (n * (fact (n - 1)))
T* infer n
T* infer Ident n
T* infer Ident n ... type schema is { vars:[] body:int!}
T* infer Ident n ... ts alpha = { vars:[] body:int}
T* infer n result = int
T* infer (fact (n - 1))
T* infer fact
T* infer Ident fact
T* infer Ident fact ... type schema is { vars:[] body:'31}
T* infer Ident fact ... ts alpha = { vars:[] body:'31}
T* infer fact result = '31
T* infer (n - 1)
T* infer n
T* infer Ident n
T* infer Ident n ... type schema is { vars:[] body:int!}
T* infer Ident n ... ts alpha = { vars:[] body:int}
T* infer n result = int
T* infer 1
T* infer 1 result = int
T* infer_binary - int int
T* unify int int
T* infer (n - 1) result = int
T* unify 'a int -> 'a
T* unify result 'a ... 
T* ... int -> 'a
T* infer (fact (n - 1)) result = '33
T* infer_binary * int 'a
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (n * (fact (n - 1))) result = int
T* unify int int
T* infer (if (n < 1) then 1 else (n * (fact (n - 1)))) result = int
T* after infer int
T* infer (fn n -> (if (n < 1) then 1 else (n * (fact (n - 1))))) result = int! -> int
T* after infer int! -> int
T* infer poly type = { vars:[] body:int -> int}
T* infer (letrec fact (fn n -> (if (n < 1) then 1 else (n * (fact (n - 1)))))) result = unit
(letrec fact (fn n -> (if (n < 1) then 1 else (n * (fact (n - 1))))))
evaluated> () : unit
expected > ()
[32m.[0mtext> fact 5
T* infer (fact 5)
T* infer fact
T* infer Ident fact
T* infer Ident fact ... type schema is { vars:[] body:int -> int}
T* infer Ident fact ... ts alpha = { vars:[] body:int -> int}
T* infer fact result = int -> int
T* infer 5
T* infer 5 result = int
T* unify int -> int int -> 'a
T* unify int int
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (fact 5) result = int!
(fact 5)
evaluated> 120 : int
expected > 120
[32m.[0mtext> module A
T* infer module A
T* infer module A result = unit
module A
evaluated> () : unit
expected > ()
[32m.[0mtext> let x = 1
T* infer (let x = 1)
T* infer let x = 1
T* infer 1
T* infer 1 result = int
T* after infer int
T* poly type = { vars:[] body:int}
T* infer (let x = 1) result = unit
(let x = 1)
evaluated> () : unit
expected > ()
[32m.[0mtext> module B
T* infer module B
T* infer module B result = unit
module B
evaluated> () : unit
expected > ()
[32m.[0mtext> let x = 2
T* infer (let x = 2)
T* infer let x = 2
T* infer 2
T* infer 2 result = int
T* after infer int
T* poly type = { vars:[] body:int}
T* infer (let x = 2) result = unit
(let x = 2)
evaluated> () : unit
expected > ()
[32m.[0mtext> module Main
T* infer module Main
T* infer module Main result = unit
module Main
evaluated> () : unit
expected > ()
[32m.[0mtext> A.x
T* infer A.x
T* infer A.x result = int
A.x
evaluated> 1 : int
expected > 1
[32m.[0mtext> B.x
T* infer B.x
T* infer B.x result = int
B.x
evaluated> 2 : int
expected > 2
[32m.[0mtext> import List
T* infer import List
T* infer import List result = unit
import List
T* infer module List
T* infer module List result = unit
T* infer (letrec length (fn x -> (match x { | [] -> 0 | _ | xs -> (1 + (length xs))})))
T* infer letrec length = (fn x -> (match x { | [] -> 0 | _ | xs -> (1 + (length xs))}))
T* infer length type_schema = { vars:[] body:'35}
T* infer (fn x -> (match x { | [] -> 0 | _ | xs -> (1 + (length xs))}))
T* infer Fn (x, (match x { | [] -> 0 | _ | xs -> (1 + (length xs))}))
T* infer x ... arg type = '36
T* infer x ... arg ts = { vars:[] body:'36}
T* infer (match x { | [] -> 0 | _ | xs -> (1 + (length xs))})
T* infer_match x
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'36}
T* infer Ident x ... ts alpha = { vars:[] body:'36}
T* infer x result = '36
T* after infer 'a
T* pat_list .. (pat,expr)::rest
T* unify_pat ([], 'a)
T* unify_pat (pat, TVar (_, {contents = None}))
T* pattern_to_type []
T* unify ['a] 'a
T* unify result 'a ... 
T* ... ['a]
T* infer 0
T* infer 0 result = int
T* unify_pat (_ | xs, ['a])
T* unify_pat PatCons (_, xs)
T* unify_pat (_, 'a)
T* unify_pat (xs, ['a])
T* infer (1 + (length xs))
T* infer 1
T* infer 1 result = int
T* infer (length xs)
T* infer length
T* infer Ident length
T* infer Ident length ... type schema is { vars:[] body:'35}
T* infer Ident length ... ts alpha = { vars:[] body:'35}
T* infer length result = '35
T* infer xs
T* infer Ident xs
T* infer Ident xs ... type schema is { vars:[] body:['37]}
T* infer Ident xs ... ts alpha = { vars:[] body:['37]}
T* infer xs result = ['37]
T* unify 'a ['a] -> 'b
T* unify result 'a ... 
T* ... ['a] -> 'b
T* infer (length xs) result = '38
T* infer_binary + int 'a
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* after unify int int
T* infer (1 + (length xs)) result = int
T* unify int int
T* infer (match x { | [] -> 0 | _ | xs -> (1 + (length xs))}) result = int
T* after infer int
T* infer (fn x -> (match x { | [] -> 0 | _ | xs -> (1 + (length xs))})) result = ['37]! -> int
T* after infer ['37]! -> int
T* infer poly type = { vars:[37] body:['37] -> int}
T* infer (letrec length (fn x -> (match x { | [] -> 0 | _ | xs -> (1 + (length xs))}))) result = unit
T* infer (letrec map (fn f -> (fn x -> (match x { | [] -> [] | x | xs -> ((f x) : ((map f) xs))}))))
T* infer letrec map = (fn f -> (fn x -> (match x { | [] -> [] | x | xs -> ((f x) : ((map f) xs))})))
T* infer map type_schema = { vars:[] body:'39}
T* infer (fn f -> (fn x -> (match x { | [] -> [] | x | xs -> ((f x) : ((map f) xs))})))
T* infer Fn (f, (fn x -> (match x { | [] -> [] | x | xs -> ((f x) : ((map f) xs))})))
T* infer f ... arg type = '40
T* infer f ... arg ts = { vars:[] body:'40}
T* infer (fn x -> (match x { | [] -> [] | x | xs -> ((f x) : ((map f) xs))}))
T* infer Fn (x, (match x { | [] -> [] | x | xs -> ((f x) : ((map f) xs))}))
T* infer x ... arg type = '41
T* infer x ... arg ts = { vars:[] body:'41}
T* infer (match x { | [] -> [] | x | xs -> ((f x) : ((map f) xs))})
T* infer_match x
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'41}
T* infer Ident x ... ts alpha = { vars:[] body:'41}
T* infer x result = '41
T* after infer 'a
T* pat_list .. (pat,expr)::rest
T* unify_pat ([], 'a)
T* unify_pat (pat, TVar (_, {contents = None}))
T* pattern_to_type []
T* unify ['a] 'a
T* unify result 'a ... 
T* ... ['a]
T* infer []
T* infer [] result = ['43]
T* unify_pat (x | xs, ['a])
T* unify_pat PatCons (x, xs)
T* unify_pat (x, 'a)
T* unify_pat (xs, ['a])
T* infer ((f x) : ((map f) xs))
T* infer (f x)
T* infer f
T* infer Ident f
T* infer Ident f ... type schema is { vars:[] body:'40}
T* infer Ident f ... ts alpha = { vars:[] body:'40}
T* infer f result = '40
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'42}
T* infer Ident x ... ts alpha = { vars:[] body:'42}
T* infer x result = '42
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (f x) result = '44
T* infer ((map f) xs)
T* infer (map f)
T* infer map
T* infer Ident map
T* infer Ident map ... type schema is { vars:[] body:'39}
T* infer Ident map ... ts alpha = { vars:[] body:'39}
T* infer map result = '39
T* infer f
T* infer Ident f
T* infer Ident f ... type schema is { vars:[] body:'42 -> '44!}
T* infer Ident f ... ts alpha = { vars:[] body:'42 -> '44}
T* infer f result = '42 -> '44
T* unify 'a ('a -> 'b) -> 'c
T* unify result 'a ... 
T* ... ('a -> 'b) -> 'c
T* infer (map f) result = '45
T* infer xs
T* infer Ident xs
T* infer Ident xs ... type schema is { vars:[] body:['42]}
T* infer Ident xs ... ts alpha = { vars:[] body:['42]}
T* infer xs result = ['42]
T* unify 'a ['a] -> 'b
T* unify result 'a ... 
T* ... ['a] -> 'b
T* infer ((map f) xs) result = '46
T* infer_binary : 'a 'a
T* unify ['a] 'a
T* unify result 'a ... 
T* ... ['a]
T* infer ((f x) : ((map f) xs)) result = ['44]
T* unify ['a] ['a]
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* infer (match x { | [] -> [] | x | xs -> ((f x) : ((map f) xs))}) result = ['44!]
T* after infer ['44!]
T* infer (fn x -> (match x { | [] -> [] | x | xs -> ((f x) : ((map f) xs))})) result = ['42]! -> ['44!]
T* after infer ['42]! -> ['44!]
T* infer (fn f -> (fn x -> (match x { | [] -> [] | x | xs -> ((f x) : ((map f) xs))}))) result = ('42 -> '44)! -> ['42]! -> ['44!]
T* after infer ('42 -> '44)! -> ['42]! -> ['44!]
T* infer poly type = { vars:[44,42] body:('42 -> '44) -> ['42] -> ['44]}
T* infer (letrec map (fn f -> (fn x -> (match x { | [] -> [] | x | xs -> ((f x) : ((map f) xs))})))) result = unit
T* infer (letrec append (fn x -> (fn y -> (match x { | [] -> y | x | xs -> (x : ((append xs) y))}))))
T* infer letrec append = (fn x -> (fn y -> (match x { | [] -> y | x | xs -> (x : ((append xs) y))})))
T* infer append type_schema = { vars:[] body:'47}
T* infer (fn x -> (fn y -> (match x { | [] -> y | x | xs -> (x : ((append xs) y))})))
T* infer Fn (x, (fn y -> (match x { | [] -> y | x | xs -> (x : ((append xs) y))})))
T* infer x ... arg type = '48
T* infer x ... arg ts = { vars:[] body:'48}
T* infer (fn y -> (match x { | [] -> y | x | xs -> (x : ((append xs) y))}))
T* infer Fn (y, (match x { | [] -> y | x | xs -> (x : ((append xs) y))}))
T* infer y ... arg type = '49
T* infer y ... arg ts = { vars:[] body:'49}
T* infer (match x { | [] -> y | x | xs -> (x : ((append xs) y))})
T* infer_match x
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'48}
T* infer Ident x ... ts alpha = { vars:[] body:'48}
T* infer x result = '48
T* after infer 'a
T* pat_list .. (pat,expr)::rest
T* unify_pat ([], 'a)
T* unify_pat (pat, TVar (_, {contents = None}))
T* pattern_to_type []
T* unify ['a] 'a
T* unify result 'a ... 
T* ... ['a]
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:'49}
T* infer Ident y ... ts alpha = { vars:[] body:'49}
T* infer y result = '49
T* unify_pat (x | xs, ['a])
T* unify_pat PatCons (x, xs)
T* unify_pat (x, 'a)
T* unify_pat (xs, ['a])
T* infer (x : ((append xs) y))
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'50}
T* infer Ident x ... ts alpha = { vars:[] body:'50}
T* infer x result = '50
T* infer ((append xs) y)
T* infer (append xs)
T* infer append
T* infer Ident append
T* infer Ident append ... type schema is { vars:[] body:'47}
T* infer Ident append ... ts alpha = { vars:[] body:'47}
T* infer append result = '47
T* infer xs
T* infer Ident xs
T* infer Ident xs ... type schema is { vars:[] body:['50]}
T* infer Ident xs ... ts alpha = { vars:[] body:['50]}
T* infer xs result = ['50]
T* unify 'a ['a] -> 'b
T* unify result 'a ... 
T* ... ['a] -> 'b
T* infer (append xs) result = '51
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:'49}
T* infer Ident y ... ts alpha = { vars:[] body:'49}
T* infer y result = '49
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer ((append xs) y) result = '52
T* infer_binary : 'a 'a
T* unify ['a] 'a
T* unify result 'a ... 
T* ... ['a]
T* infer (x : ((append xs) y)) result = ['50]
T* unify 'a ['a]
T* unify result 'a ... 
T* ... ['a]
T* infer (match x { | [] -> y | x | xs -> (x : ((append xs) y))}) result = ['50]!
T* after infer ['50]!
T* infer (fn y -> (match x { | [] -> y | x | xs -> (x : ((append xs) y))})) result = ['50]! -> ['50]!
T* after infer ['50]! -> ['50]!
T* infer (fn x -> (fn y -> (match x { | [] -> y | x | xs -> (x : ((append xs) y))}))) result = ['50]! -> ['50]! -> ['50]!
T* after infer ['50]! -> ['50]! -> ['50]!
T* infer poly type = { vars:[50] body:['50] -> ['50] -> ['50]}
T* infer (letrec append (fn x -> (fn y -> (match x { | [] -> y | x | xs -> (x : ((append xs) y))})))) result = unit
T* infer (letrec reverse (fn x -> (match x { | [] -> [] | x | xs -> ((append (reverse xs)) (x : []))})))
T* infer letrec reverse = (fn x -> (match x { | [] -> [] | x | xs -> ((append (reverse xs)) (x : []))}))
T* infer reverse type_schema = { vars:[] body:'53}
T* infer (fn x -> (match x { | [] -> [] | x | xs -> ((append (reverse xs)) (x : []))}))
T* infer Fn (x, (match x { | [] -> [] | x | xs -> ((append (reverse xs)) (x : []))}))
T* infer x ... arg type = '54
T* infer x ... arg ts = { vars:[] body:'54}
T* infer (match x { | [] -> [] | x | xs -> ((append (reverse xs)) (x : []))})
T* infer_match x
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'54}
T* infer Ident x ... ts alpha = { vars:[] body:'54}
T* infer x result = '54
T* after infer 'a
T* pat_list .. (pat,expr)::rest
T* unify_pat ([], 'a)
T* unify_pat (pat, TVar (_, {contents = None}))
T* pattern_to_type []
T* unify ['a] 'a
T* unify result 'a ... 
T* ... ['a]
T* infer []
T* infer [] result = ['56]
T* unify_pat (x | xs, ['a])
T* unify_pat PatCons (x, xs)
T* unify_pat (x, 'a)
T* unify_pat (xs, ['a])
T* infer ((append (reverse xs)) (x : []))
T* infer (append (reverse xs))
T* infer append
T* infer Ident append
T* infer Ident append ... type schema is { vars:[50] body:['50] -> ['50] -> ['50]}
T* infer Ident append ... ts alpha = { vars:[57] body:['57] -> ['57] -> ['57]}
T* infer append result = ['57] -> ['57] -> ['57]
T* infer (reverse xs)
T* infer reverse
T* infer Ident reverse
T* infer Ident reverse ... type schema is { vars:[] body:'53}
T* infer Ident reverse ... ts alpha = { vars:[] body:'53}
T* infer reverse result = '53
T* infer xs
T* infer Ident xs
T* infer Ident xs ... type schema is { vars:[] body:['55]}
T* infer Ident xs ... ts alpha = { vars:[] body:['55]}
T* infer xs result = ['55]
T* unify 'a ['a] -> 'b
T* unify result 'a ... 
T* ... ['a] -> 'b
T* infer (reverse xs) result = '58
T* unify ['a] -> ['a] -> ['a] 'a -> 'b
T* unify ['a] 'a
T* unify result 'a ... 
T* ... ['a]
T* unify ['a] -> ['a] 'a
T* unify result 'a ... 
T* ... ['a] -> ['a]
T* infer (append (reverse xs)) result = ['57] -> ['57]!
T* infer (x : [])
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'55}
T* infer Ident x ... ts alpha = { vars:[] body:'55}
T* infer x result = '55
T* infer []
T* infer [] result = ['60]
T* infer_binary : 'a ['a]
T* unify ['a] ['a]
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* infer (x : []) result = ['60!]
T* unify ['a] -> ['a] ['a] -> 'b
T* unify ['a] -> ['a] ['a] -> 'b
T* unify ['a] ['a]
T* unify 'a 'a
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* unify ['a] 'a
T* unify result 'a ... 
T* ... ['a]
T* infer ((append (reverse xs)) (x : [])) result = ['60!]!
T* unify ['a] ['a]
T* unify ['a] ['a]
T* unify 'a 'a
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* infer (match x { | [] -> [] | x | xs -> ((append (reverse xs)) (x : []))}) result = ['60!]
T* after infer ['60!]
T* infer (fn x -> (match x { | [] -> [] | x | xs -> ((append (reverse xs)) (x : []))})) result = ['60!]! -> ['60!]
T* after infer ['60!]! -> ['60!]
T* infer poly type = { vars:[60] body:['60] -> ['60]}
T* infer (letrec reverse (fn x -> (match x { | [] -> [] | x | xs -> ((append (reverse xs)) (x : []))}))) result = unit
T* infer (letrec filter (fn p -> (fn x -> (match x { | [] -> [] | x | xs -> (if (p x) then (x : ((filter p) xs)) else ((filter p) xs))}))))
T* infer letrec filter = (fn p -> (fn x -> (match x { | [] -> [] | x | xs -> (if (p x) then (x : ((filter p) xs)) else ((filter p) xs))})))
T* infer filter type_schema = { vars:[] body:'62}
T* infer (fn p -> (fn x -> (match x { | [] -> [] | x | xs -> (if (p x) then (x : ((filter p) xs)) else ((filter p) xs))})))
T* infer Fn (p, (fn x -> (match x { | [] -> [] | x | xs -> (if (p x) then (x : ((filter p) xs)) else ((filter p) xs))})))
T* infer p ... arg type = '63
T* infer p ... arg ts = { vars:[] body:'63}
T* infer (fn x -> (match x { | [] -> [] | x | xs -> (if (p x) then (x : ((filter p) xs)) else ((filter p) xs))}))
T* infer Fn (x, (match x { | [] -> [] | x | xs -> (if (p x) then (x : ((filter p) xs)) else ((filter p) xs))}))
T* infer x ... arg type = '64
T* infer x ... arg ts = { vars:[] body:'64}
T* infer (match x { | [] -> [] | x | xs -> (if (p x) then (x : ((filter p) xs)) else ((filter p) xs))})
T* infer_match x
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'64}
T* infer Ident x ... ts alpha = { vars:[] body:'64}
T* infer x result = '64
T* after infer 'a
T* pat_list .. (pat,expr)::rest
T* unify_pat ([], 'a)
T* unify_pat (pat, TVar (_, {contents = None}))
T* pattern_to_type []
T* unify ['a] 'a
T* unify result 'a ... 
T* ... ['a]
T* infer []
T* infer [] result = ['66]
T* unify_pat (x | xs, ['a])
T* unify_pat PatCons (x, xs)
T* unify_pat (x, 'a)
T* unify_pat (xs, ['a])
T* infer (if (p x) then (x : ((filter p) xs)) else ((filter p) xs))
T* infer If (p x) then (x : ((filter p) xs)) else ((filter p) xs)
T* infer (p x)
T* infer p
T* infer Ident p
T* infer Ident p ... type schema is { vars:[] body:'63}
T* infer Ident p ... ts alpha = { vars:[] body:'63}
T* infer p result = '63
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'65}
T* infer Ident x ... ts alpha = { vars:[] body:'65}
T* infer x result = '65
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (p x) result = '67
T* unify bool 'a
T* unify result 'a ... 
T* ... bool
T* infer (x : ((filter p) xs))
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'65}
T* infer Ident x ... ts alpha = { vars:[] body:'65}
T* infer x result = '65
T* infer ((filter p) xs)
T* infer (filter p)
T* infer filter
T* infer Ident filter
T* infer Ident filter ... type schema is { vars:[] body:'62}
T* infer Ident filter ... ts alpha = { vars:[] body:'62}
T* infer filter result = '62
T* infer p
T* infer Ident p
T* infer Ident p ... type schema is { vars:[] body:'65 -> bool!!}
T* infer Ident p ... ts alpha = { vars:[] body:'65 -> bool}
T* infer p result = '65 -> bool
T* unify 'a ('a -> bool) -> 'b
T* unify result 'a ... 
T* ... ('a -> bool) -> 'b
T* infer (filter p) result = '68
T* infer xs
T* infer Ident xs
T* infer Ident xs ... type schema is { vars:[] body:['65]}
T* infer Ident xs ... ts alpha = { vars:[] body:['65]}
T* infer xs result = ['65]
T* unify 'a ['a] -> 'b
T* unify result 'a ... 
T* ... ['a] -> 'b
T* infer ((filter p) xs) result = '69
T* infer_binary : 'a 'a
T* unify ['a] 'a
T* unify result 'a ... 
T* ... ['a]
T* infer (x : ((filter p) xs)) result = ['65]
T* infer ((filter p) xs)
T* infer (filter p)
T* infer filter
T* infer Ident filter
T* infer Ident filter ... type schema is { vars:[] body:('65 -> bool) -> ['65] -> ['65]!!!}
T* infer Ident filter ... ts alpha = { vars:[] body:('65 -> bool) -> ['65] -> ['65]}
T* infer filter result = ('65 -> bool) -> ['65] -> ['65]
T* infer p
T* infer Ident p
T* infer Ident p ... type schema is { vars:[] body:'65 -> bool!!}
T* infer Ident p ... ts alpha = { vars:[] body:'65 -> bool}
T* infer p result = '65 -> bool
T* unify ('a -> bool) -> ['a] -> ['a] ('a -> bool) -> 'b
T* unify 'a -> bool 'a -> bool
T* unify 'a 'a
T* unify bool bool
T* unify ['a] -> ['a] 'a
T* unify result 'a ... 
T* ... ['a] -> ['a]
T* infer (filter p) result = ['65] -> ['65]!
T* infer xs
T* infer Ident xs
T* infer Ident xs ... type schema is { vars:[] body:['65]}
T* infer Ident xs ... ts alpha = { vars:[] body:['65]}
T* infer xs result = ['65]
T* unify ['a] -> ['a] ['a] -> 'b
T* unify ['a] -> ['a] ['a] -> 'b
T* unify ['a] ['a]
T* unify 'a 'a
T* unify ['a] 'a
T* unify result 'a ... 
T* ... ['a]
T* infer ((filter p) xs) result = ['65]!
T* unify ['a] ['a]
T* unify ['a] ['a]
T* unify 'a 'a
T* infer (if (p x) then (x : ((filter p) xs)) else ((filter p) xs)) result = ['65]
T* unify ['a] ['a]
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* infer (match x { | [] -> [] | x | xs -> (if (p x) then (x : ((filter p) xs)) else ((filter p) xs))}) result = ['65!]
T* after infer ['65!]
T* infer (fn x -> (match x { | [] -> [] | x | xs -> (if (p x) then (x : ((filter p) xs)) else ((filter p) xs))})) result = ['65]! -> ['65!]
T* after infer ['65]! -> ['65!]
T* infer (fn p -> (fn x -> (match x { | [] -> [] | x | xs -> (if (p x) then (x : ((filter p) xs)) else ((filter p) xs))}))) result = ('65 -> bool!)! -> ['65]! -> ['65!]
T* after infer ('65 -> bool!)! -> ['65]! -> ['65!]
T* infer poly type = { vars:[65] body:('65 -> bool) -> ['65] -> ['65]}
T* infer (letrec filter (fn p -> (fn x -> (match x { | [] -> [] | x | xs -> (if (p x) then (x : ((filter p) xs)) else ((filter p) xs))})))) result = unit
evaluated> () : unit
expected > ()
[32m.[0mtext> List.length [1,2,3]
T* infer (List.length (1 : (2 : (3 : []))))
T* infer List.length
T* infer List.length result = ['72] -> int
T* infer (1 : (2 : (3 : [])))
T* infer 1
T* infer 1 result = int
T* infer (2 : (3 : []))
T* infer 2
T* infer 2 result = int
T* infer (3 : [])
T* infer 3
T* infer 3 result = int
T* infer []
T* infer [] result = ['73]
T* infer_binary : int ['a]
T* unify [int] ['a]
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (3 : []) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (2 : (3 : [])) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (1 : (2 : (3 : []))) result = [int]
T* unify ['a] -> int [int] -> 'a
T* unify ['a] [int]
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (List.length (1 : (2 : (3 : [])))) result = int!
(List.length (1 : (2 : (3 : []))))
evaluated> 3 : int
expected > 3
[32m.[0mtext> import List as L
T* infer import List as L
T* infer import List as L result = unit
import List as L
evaluated> () : unit
expected > ()
[32m.[0mtext> L.length [1,2,3,4]
T* infer (L.length (1 : (2 : (3 : (4 : [])))))
T* infer L.length
T* infer L.length result = ['75] -> int
T* infer (1 : (2 : (3 : (4 : []))))
T* infer 1
T* infer 1 result = int
T* infer (2 : (3 : (4 : [])))
T* infer 2
T* infer 2 result = int
T* infer (3 : (4 : []))
T* infer 3
T* infer 3 result = int
T* infer (4 : [])
T* infer 4
T* infer 4 result = int
T* infer []
T* infer [] result = ['76]
T* infer_binary : int ['a]
T* unify [int] ['a]
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (4 : []) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (3 : (4 : [])) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (2 : (3 : (4 : []))) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (1 : (2 : (3 : (4 : [])))) result = [int]
T* unify ['a] -> int [int] -> 'a
T* unify ['a] [int]
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (L.length (1 : (2 : (3 : (4 : []))))) result = int!
(L.length (1 : (2 : (3 : (4 : [])))))
evaluated> 4 : int
expected > 4
[32m.[0mtext> fst (1,2)
T* infer (fst (1, 2))
T* infer fst
T* infer Ident fst
T* infer Ident fst ... type schema is { vars:[3,2] body:('c, 'd) -> 'c}
T* infer Ident fst ... ts alpha = { vars:[78,79] body:('79, '78) -> '79}
T* infer fst result = ('79, '78) -> '79
T* infer (1, 2)
T* infer 1
T* infer 1 result = int
T* infer 2
T* infer 2 result = int
T* infer (1, 2) result = (int, int)
T* unify ('a, 'b) -> 'a (int, int) -> 'a
T* unify ('a, 'b) (int, int)
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify int 'a
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (fst (1, 2)) result = int!
(fst (1, 2))
evaluated> 1 : int
expected > 1
[32m.[0mtext> snd (1,2)
T* infer (snd (1, 2))
T* infer snd
T* infer Ident snd
T* infer Ident snd ... type schema is { vars:[4,5] body:('f, 'e) -> 'e}
T* infer Ident snd ... ts alpha = { vars:[81,82] body:('82, '81) -> '81}
T* infer snd result = ('82, '81) -> '81
T* infer (1, 2)
T* infer 1
T* infer 1 result = int
T* infer 2
T* infer 2 result = int
T* infer (1, 2) result = (int, int)
T* unify ('a, 'b) -> 'b (int, int) -> 'a
T* unify ('a, 'b) (int, int)
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify int 'a
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (snd (1, 2)) result = int!
(snd (1, 2))
evaluated> 2 : int
expected > 2
[32m.[0mtext> (fn n -> match n { 0 -> 'a' | 1 -> 'b' | 2 -> 'c' }) 1
T* infer ((fn n -> (match n { | 0 -> 'a' | 1 -> 'b' | 2 -> 'c'})) 1)
T* infer (fn n -> (match n { | 0 -> 'a' | 1 -> 'b' | 2 -> 'c'}))
T* infer Fn (n, (match n { | 0 -> 'a' | 1 -> 'b' | 2 -> 'c'}))
T* infer n ... arg type = '84
T* infer n ... arg ts = { vars:[] body:'84}
T* infer (match n { | 0 -> 'a' | 1 -> 'b' | 2 -> 'c'})
T* infer_match n
T* infer n
T* infer Ident n
T* infer Ident n ... type schema is { vars:[] body:'84}
T* infer Ident n ... ts alpha = { vars:[] body:'84}
T* infer n result = '84
T* after infer 'a
T* pat_list .. (pat,expr)::rest
T* unify_pat (0, 'a)
T* unify_pat (pat, TVar (_, {contents = None}))
T* pattern_to_type 0
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer 'a'
T* infer 'a' result = char
T* unify_pat (1, int)
T* infer 'b'
T* infer 'b' result = char
T* unify char char
T* unify_pat (2, int)
T* infer 'c'
T* infer 'c' result = char
T* unify char char
T* infer (match n { | 0 -> 'a' | 1 -> 'b' | 2 -> 'c'}) result = char
T* after infer char
T* infer (fn n -> (match n { | 0 -> 'a' | 1 -> 'b' | 2 -> 'c'})) result = int! -> char
T* infer 1
T* infer 1 result = int
T* unify int -> char int -> 'a
T* unify int int
T* unify int int
T* unify char 'a
T* unify result 'a ... 
T* ... char
T* infer ((fn n -> (match n { | 0 -> 'a' | 1 -> 'b' | 2 -> 'c'})) 1) result = char!
((fn n -> (match n { | 0 -> 'a' | 1 -> 'b' | 2 -> 'c'})) 1)
evaluated> b : char
expected > b
[32m.[0mtext> (fn n -> match n { (_,_,x) -> x }) (1,2,3)
T* infer ((fn n -> (match n { |  _ _ x -> x})) (1, 2, 3))
T* infer (fn n -> (match n { |  _ _ x -> x}))
T* infer Fn (n, (match n { |  _ _ x -> x}))
T* infer n ... arg type = '86
T* infer n ... arg ts = { vars:[] body:'86}
T* infer (match n { |  _ _ x -> x})
T* infer_match n
T* infer n
T* infer Ident n
T* infer Ident n ... type schema is { vars:[] body:'86}
T* infer Ident n ... ts alpha = { vars:[] body:'86}
T* infer n result = '86
T* after infer 'a
T* pat_list .. [(pat,expr)]
T* unify_pat ( _ _ x, 'a)
T* unify_pat (pat, TVar (_, {contents = None}))
T* pattern_to_type  _ _ x
T* pattern_to_type _
T* pattern_to_type _
T* pattern_to_type x
T* unify ('a, 'b, 'c) 'a
T* unify result 'a ... 
T* ... ('a, 'b, 'c)
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'89}
T* infer Ident x ... ts alpha = { vars:[] body:'89}
T* infer x result = '89
T* infer (match n { |  _ _ x -> x}) result = '89
T* after infer '89
T* infer (fn n -> (match n { |  _ _ x -> x})) result = ('87, '88, '89)! -> '89
T* infer (1, 2, 3)
T* infer 1
T* infer 1 result = int
T* infer 2
T* infer 2 result = int
T* infer 3
T* infer 3 result = int
T* infer (1, 2, 3) result = (int, int, int)
T* unify ('a, 'b, 'c) -> 'c (int, int, int) -> 'a
T* unify ('a, 'b, 'c) (int, int, int)
T* unify ('a, 'b, 'c) (int, int, int)
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify int 'a
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer ((fn n -> (match n { |  _ _ x -> x})) (1, 2, 3)) result = int!
((fn n -> (match n { |  _ _ x -> x})) (1, 2, 3))
evaluated> 3 : int
expected > 3
[32m.[0mtext> (fn n -> match n { 0 | 1 | 2 -> 'a' | 3 -> 'b' }) 1
T* infer ((fn n -> (match n { | 0:1:2 -> 'a' | 3 -> 'b'})) 1)
T* infer (fn n -> (match n { | 0:1:2 -> 'a' | 3 -> 'b'}))
T* infer Fn (n, (match n { | 0:1:2 -> 'a' | 3 -> 'b'}))
T* infer n ... arg type = '91
T* infer n ... arg ts = { vars:[] body:'91}
T* infer (match n { | 0:1:2 -> 'a' | 3 -> 'b'})
T* infer_match n
T* infer n
T* infer Ident n
T* infer Ident n ... type schema is { vars:[] body:'91}
T* infer Ident n ... ts alpha = { vars:[] body:'91}
T* infer n result = '91
T* after infer 'a
T* pat_list .. (pat,expr)::rest
T* unify_pat (0:1:2, 'a)
T* unify_pat (0, 'a)
T* unify_pat (pat, TVar (_, {contents = None}))
T* pattern_to_type 0
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* unify_pat (1:2, int)
T* unify_pat (1, int)
T* unify_pat (2, int)
T* infer 'a'
T* infer 'a' result = char
T* unify_pat (3, int)
T* infer 'b'
T* infer 'b' result = char
T* unify char char
T* infer (match n { | 0:1:2 -> 'a' | 3 -> 'b'}) result = char
T* after infer char
T* infer (fn n -> (match n { | 0:1:2 -> 'a' | 3 -> 'b'})) result = int! -> char
T* infer 1
T* infer 1 result = int
T* unify int -> char int -> 'a
T* unify int int
T* unify int int
T* unify char 'a
T* unify result 'a ... 
T* ... char
T* infer ((fn n -> (match n { | 0:1:2 -> 'a' | 3 -> 'b'})) 1) result = char!
((fn n -> (match n { | 0:1:2 -> 'a' | 3 -> 'b'})) 1)
evaluated> a : char
expected > a
[32m.[0mtext> (fn n -> match n { 0 | 1 | 2 -> 'a' | 3 -> 'b' }) 2
T* infer ((fn n -> (match n { | 0:1:2 -> 'a' | 3 -> 'b'})) 2)
T* infer (fn n -> (match n { | 0:1:2 -> 'a' | 3 -> 'b'}))
T* infer Fn (n, (match n { | 0:1:2 -> 'a' | 3 -> 'b'}))
T* infer n ... arg type = '93
T* infer n ... arg ts = { vars:[] body:'93}
T* infer (match n { | 0:1:2 -> 'a' | 3 -> 'b'})
T* infer_match n
T* infer n
T* infer Ident n
T* infer Ident n ... type schema is { vars:[] body:'93}
T* infer Ident n ... ts alpha = { vars:[] body:'93}
T* infer n result = '93
T* after infer 'a
T* pat_list .. (pat,expr)::rest
T* unify_pat (0:1:2, 'a)
T* unify_pat (0, 'a)
T* unify_pat (pat, TVar (_, {contents = None}))
T* pattern_to_type 0
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* unify_pat (1:2, int)
T* unify_pat (1, int)
T* unify_pat (2, int)
T* infer 'a'
T* infer 'a' result = char
T* unify_pat (3, int)
T* infer 'b'
T* infer 'b' result = char
T* unify char char
T* infer (match n { | 0:1:2 -> 'a' | 3 -> 'b'}) result = char
T* after infer char
T* infer (fn n -> (match n { | 0:1:2 -> 'a' | 3 -> 'b'})) result = int! -> char
T* infer 2
T* infer 2 result = int
T* unify int -> char int -> 'a
T* unify int int
T* unify int int
T* unify char 'a
T* unify result 'a ... 
T* ... char
T* infer ((fn n -> (match n { | 0:1:2 -> 'a' | 3 -> 'b'})) 2) result = char!
((fn n -> (match n { | 0:1:2 -> 'a' | 3 -> 'b'})) 2)
evaluated> a : char
expected > a
[32m.[0mtext> (fn n -> match n { 0 | 1 | 2 -> 'a' | 3 -> 'b' }) 3
T* infer ((fn n -> (match n { | 0:1:2 -> 'a' | 3 -> 'b'})) 3)
T* infer (fn n -> (match n { | 0:1:2 -> 'a' | 3 -> 'b'}))
T* infer Fn (n, (match n { | 0:1:2 -> 'a' | 3 -> 'b'}))
T* infer n ... arg type = '95
T* infer n ... arg ts = { vars:[] body:'95}
T* infer (match n { | 0:1:2 -> 'a' | 3 -> 'b'})
T* infer_match n
T* infer n
T* infer Ident n
T* infer Ident n ... type schema is { vars:[] body:'95}
T* infer Ident n ... ts alpha = { vars:[] body:'95}
T* infer n result = '95
T* after infer 'a
T* pat_list .. (pat,expr)::rest
T* unify_pat (0:1:2, 'a)
T* unify_pat (0, 'a)
T* unify_pat (pat, TVar (_, {contents = None}))
T* pattern_to_type 0
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* unify_pat (1:2, int)
T* unify_pat (1, int)
T* unify_pat (2, int)
T* infer 'a'
T* infer 'a' result = char
T* unify_pat (3, int)
T* infer 'b'
T* infer 'b' result = char
T* unify char char
T* infer (match n { | 0:1:2 -> 'a' | 3 -> 'b'}) result = char
T* after infer char
T* infer (fn n -> (match n { | 0:1:2 -> 'a' | 3 -> 'b'})) result = int! -> char
T* infer 3
T* infer 3 result = int
T* unify int -> char int -> 'a
T* unify int int
T* unify int int
T* unify char 'a
T* unify result 'a ... 
T* ... char
T* infer ((fn n -> (match n { | 0:1:2 -> 'a' | 3 -> 'b'})) 3) result = char!
((fn n -> (match n { | 0:1:2 -> 'a' | 3 -> 'b'})) 3)
evaluated> b : char
expected > b
[32m.[0mtext> match [1,2,3] { [a,b,c] as d -> a }
T* infer (match (1 : (2 : (3 : []))) { | ([ a b c]) as d -> a})
T* infer_match (1 : (2 : (3 : [])))
T* infer (1 : (2 : (3 : [])))
T* infer 1
T* infer 1 result = int
T* infer (2 : (3 : []))
T* infer 2
T* infer 2 result = int
T* infer (3 : [])
T* infer 3
T* infer 3 result = int
T* infer []
T* infer [] result = ['97]
T* infer_binary : int ['a]
T* unify [int] ['a]
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (3 : []) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (2 : (3 : [])) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (1 : (2 : (3 : []))) result = [int]
T* after infer [int]
T* pat_list .. [(pat,expr)]
T* unify_pat (([ a b c]) as d, [int])
T* unify_pat ([ a b c], [int])
T* unify_pat (PatList (x::xs), t)
T* pattern_to_type a
T* pattern_to_type b
T* pattern_to_type c
[31m![0mType error: pattern list type error
text> match [1,2,3] { [a,b,c] as d -> b }
T* infer (match (1 : (2 : (3 : []))) { | ([ a b c]) as d -> b})
T* infer_match (1 : (2 : (3 : [])))
T* infer (1 : (2 : (3 : [])))
T* infer 1
T* infer 1 result = int
T* infer (2 : (3 : []))
T* infer 2
T* infer 2 result = int
T* infer (3 : [])
T* infer 3
T* infer 3 result = int
T* infer []
T* infer [] result = ['101]
T* infer_binary : int ['a]
T* unify [int] ['a]
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (3 : []) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (2 : (3 : [])) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (1 : (2 : (3 : []))) result = [int]
T* after infer [int]
T* pat_list .. [(pat,expr)]
T* unify_pat (([ a b c]) as d, [int])
T* unify_pat ([ a b c], [int])
T* unify_pat (PatList (x::xs), t)
T* pattern_to_type a
T* pattern_to_type b
T* pattern_to_type c
[31m![0mType error: pattern list type error
text> match [1,2,3] { [a,b,c] as d -> c }
T* infer (match (1 : (2 : (3 : []))) { | ([ a b c]) as d -> c})
T* infer_match (1 : (2 : (3 : [])))
T* infer (1 : (2 : (3 : [])))
T* infer 1
T* infer 1 result = int
T* infer (2 : (3 : []))
T* infer 2
T* infer 2 result = int
T* infer (3 : [])
T* infer 3
T* infer 3 result = int
T* infer []
T* infer [] result = ['105]
T* infer_binary : int ['a]
T* unify [int] ['a]
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (3 : []) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (2 : (3 : [])) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (1 : (2 : (3 : []))) result = [int]
T* after infer [int]
T* pat_list .. [(pat,expr)]
T* unify_pat (([ a b c]) as d, [int])
T* unify_pat ([ a b c], [int])
T* unify_pat (PatList (x::xs), t)
T* pattern_to_type a
T* pattern_to_type b
T* pattern_to_type c
[31m![0mType error: pattern list type error
text> match [1,2,3] { [a,b,c] as d -> d }
T* infer (match (1 : (2 : (3 : []))) { | ([ a b c]) as d -> d})
T* infer_match (1 : (2 : (3 : [])))
T* infer (1 : (2 : (3 : [])))
T* infer 1
T* infer 1 result = int
T* infer (2 : (3 : []))
T* infer 2
T* infer 2 result = int
T* infer (3 : [])
T* infer 3
T* infer 3 result = int
T* infer []
T* infer [] result = ['109]
T* infer_binary : int ['a]
T* unify [int] ['a]
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (3 : []) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (2 : (3 : [])) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (1 : (2 : (3 : []))) result = [int]
T* after infer [int]
T* pat_list .. [(pat,expr)]
T* unify_pat (([ a b c]) as d, [int])
T* unify_pat ([ a b c], [int])
T* unify_pat (PatList (x::xs), t)
T* pattern_to_type a
T* pattern_to_type b
T* pattern_to_type c
[31m![0mType error: pattern list type error
text> match [1,2,3] { x:xs -> x }
T* infer (match (1 : (2 : (3 : []))) { | x | xs -> x})
T* infer_match (1 : (2 : (3 : [])))
T* infer (1 : (2 : (3 : [])))
T* infer 1
T* infer 1 result = int
T* infer (2 : (3 : []))
T* infer 2
T* infer 2 result = int
T* infer (3 : [])
T* infer 3
T* infer 3 result = int
T* infer []
T* infer [] result = ['113]
T* infer_binary : int ['a]
T* unify [int] ['a]
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (3 : []) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (2 : (3 : [])) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (1 : (2 : (3 : []))) result = [int]
T* after infer [int]
T* pat_list .. [(pat,expr)]
T* unify_pat (x | xs, [int])
T* unify_pat PatCons (x, xs)
T* unify_pat (x, int)
T* unify_pat (xs, [int])
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:int}
T* infer Ident x ... ts alpha = { vars:[] body:int}
T* infer x result = int
T* infer (match (1 : (2 : (3 : []))) { | x | xs -> x}) result = int
(match (1 : (2 : (3 : []))) { | x | xs -> x})
evaluated> 1 : int
expected > 1
[32m.[0mtext> match [1,2,3] { x:y:xs -> y }
T* infer (match (1 : (2 : (3 : []))) { | x | y | xs -> y})
T* infer_match (1 : (2 : (3 : [])))
T* infer (1 : (2 : (3 : [])))
T* infer 1
T* infer 1 result = int
T* infer (2 : (3 : []))
T* infer 2
T* infer 2 result = int
T* infer (3 : [])
T* infer 3
T* infer 3 result = int
T* infer []
T* infer [] result = ['114]
T* infer_binary : int ['a]
T* unify [int] ['a]
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (3 : []) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (2 : (3 : [])) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (1 : (2 : (3 : []))) result = [int]
T* after infer [int]
T* pat_list .. [(pat,expr)]
T* unify_pat (x | y | xs, [int])
T* unify_pat PatCons (x, y | xs)
T* unify_pat (x, int)
T* unify_pat (y | xs, [int])
T* unify_pat PatCons (y, xs)
T* unify_pat (y, int)
T* unify_pat (xs, [int])
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:int}
T* infer Ident y ... ts alpha = { vars:[] body:int}
T* infer y result = int
T* infer (match (1 : (2 : (3 : []))) { | x | y | xs -> y}) result = int
(match (1 : (2 : (3 : []))) { | x | y | xs -> y})
evaluated> 2 : int
expected > 2
[32m.[0mtext> match [1,2,3] { x:xs -> xs }
T* infer (match (1 : (2 : (3 : []))) { | x | xs -> xs})
T* infer_match (1 : (2 : (3 : [])))
T* infer (1 : (2 : (3 : [])))
T* infer 1
T* infer 1 result = int
T* infer (2 : (3 : []))
T* infer 2
T* infer 2 result = int
T* infer (3 : [])
T* infer 3
T* infer 3 result = int
T* infer []
T* infer [] result = ['115]
T* infer_binary : int ['a]
T* unify [int] ['a]
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (3 : []) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (2 : (3 : [])) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (1 : (2 : (3 : []))) result = [int]
T* after infer [int]
T* pat_list .. [(pat,expr)]
T* unify_pat (x | xs, [int])
T* unify_pat PatCons (x, xs)
T* unify_pat (x, int)
T* unify_pat (xs, [int])
T* infer xs
T* infer Ident xs
T* infer Ident xs ... type schema is { vars:[] body:[int]}
T* infer Ident xs ... ts alpha = { vars:[] body:[int]}
T* infer xs result = [int]
T* infer (match (1 : (2 : (3 : []))) { | x | xs -> xs}) result = [int]
(match (1 : (2 : (3 : []))) { | x | xs -> xs})
evaluated> [2, 3] : [int]
expected > [2, 3]
[32m.[0m
Type Print 
result: (int, int)
expect: (int, int)
[32m.[0mresult: (int, int, int)
expect: (int, int, int)
[32m.[0mresult: ((int, int), int)
expect: ((int, int), int)
[32m.[0mresult: (int, (int, int))
expect: (int, (int, int))
[32m.[0mresult: ((int, int), (int, int))
expect: ((int, int), (int, int))
[32m.[0mresult: int -> int
expect: int -> int
[32m.[0mresult: int -> int -> int
expect: int -> int -> int
[32m.[0mresult: (int -> int) -> int
expect: (int -> int) -> int
[32m.[0mresult: int -> (int, int)
expect: int -> (int, int)
[32m.[0mresult: (int, int) -> int
expect: (int, int) -> int
[32m.[0mresult: [int]
expect: [int]
[32m.[0mresult: [(int, int, int)]
expect: [(int, int, int)]
[32m.[0mresult: [int -> int]
expect: [int -> int]
[32m.[0mresult: [(int -> int) -> int]
expect: [(int -> int) -> int]
[32m.[0m
Type text> 'c'
T* infer 'c'
T* infer 'c' result = char
infer    > char
expected > char
[32m.[0mtext> "abc"
T* infer "abc"
T* infer "abc" result = string
infer    > string
expected > string
[32m.[0mtext> 12
T* infer 12
T* infer 12 result = int
infer    > int
expected > int
[32m.[0mtext> 300+12
T* infer (300 + 12)
T* infer 300
T* infer 300 result = int
T* infer 12
T* infer 12 result = int
T* infer_binary + int int
T* unify int int
T* after unify int int
T* infer (300 + 12) result = int
infer    > int
expected > int
[32m.[0mtext> 300*12+3
T* infer ((300 * 12) + 3)
T* infer (300 * 12)
T* infer 300
T* infer 300 result = int
T* infer 12
T* infer 12 result = int
T* infer_binary * int int
T* unify int int
T* infer (300 * 12) result = int
T* infer 3
T* infer 3 result = int
T* infer_binary + int int
T* unify int int
T* after unify int int
T* infer ((300 * 12) + 3) result = int
infer    > int
expected > int
[32m.[0mtext> 300*(12+3)
T* infer (300 * (12 + 3))
T* infer 300
T* infer 300 result = int
T* infer (12 + 3)
T* infer 12
T* infer 12 result = int
T* infer 3
T* infer 3 result = int
T* infer_binary + int int
T* unify int int
T* after unify int int
T* infer (12 + 3) result = int
T* infer_binary * int int
T* unify int int
T* infer (300 * (12 + 3)) result = int
infer    > int
expected > int
[32m.[0mtext> fn x -> x + 1
T* infer (fn x -> (x + 1))
T* infer Fn (x, (x + 1))
T* infer x ... arg type = '116
T* infer x ... arg ts = { vars:[] body:'116}
T* infer (x + 1)
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'116}
T* infer Ident x ... ts alpha = { vars:[] body:'116}
T* infer x result = '116
T* infer 1
T* infer 1 result = int
T* infer_binary + 'a int
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* after unify int int
T* infer (x + 1) result = int!
T* after infer int!
T* infer (fn x -> (x + 1)) result = int! -> int!
infer    > int -> int
expected > int -> int
[32m.[0mtext> fn _ -> ()
T* infer (fn _ -> ())
T* infer ()
T* infer () result = unit
T* infer (fn _ -> ()) result = '117 -> unit
infer    > 'a -> unit
expected > 'a -> unit
[32m.[0mtext> (fn x -> x + 1) (300 * (12 + 3))
T* infer ((fn x -> (x + 1)) (300 * (12 + 3)))
T* infer (fn x -> (x + 1))
T* infer Fn (x, (x + 1))
T* infer x ... arg type = '118
T* infer x ... arg ts = { vars:[] body:'118}
T* infer (x + 1)
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'118}
T* infer Ident x ... ts alpha = { vars:[] body:'118}
T* infer x result = '118
T* infer 1
T* infer 1 result = int
T* infer_binary + 'a int
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* after unify int int
T* infer (x + 1) result = int!
T* after infer int!
T* infer (fn x -> (x + 1)) result = int! -> int!
T* infer (300 * (12 + 3))
T* infer 300
T* infer 300 result = int
T* infer (12 + 3)
T* infer 12
T* infer 12 result = int
T* infer 3
T* infer 3 result = int
T* infer_binary + int int
T* unify int int
T* after unify int int
T* infer (12 + 3) result = int
T* infer_binary * int int
T* unify int int
T* infer (300 * (12 + 3)) result = int
T* unify int -> int int -> 'a
T* unify int int
T* unify int int
T* unify int 'a
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer ((fn x -> (x + 1)) (300 * (12 + 3))) result = int!
infer    > int
expected > int
[32m.[0mtext> 1+2 < 3*4
T* infer ((1 + 2) < (3 * 4))
T* infer (1 + 2)
T* infer 1
T* infer 1 result = int
T* infer 2
T* infer 2 result = int
T* infer_binary + int int
T* unify int int
T* after unify int int
T* infer (1 + 2) result = int
T* infer (3 * 4)
T* infer 3
T* infer 3 result = int
T* infer 4
T* infer 4 result = int
T* infer_binary * int int
T* unify int int
T* infer (3 * 4) result = int
T* infer_binary < int int
T* unify int int
T* infer ((1 + 2) < (3 * 4)) result = bool
infer    > bool
expected > bool
[32m.[0mtext> 2 * -(1+2)
T* infer (2 * (-(1 + 2)))
T* infer 2
T* infer 2 result = int
T* infer (-(1 + 2))
T* infer (1 + 2)
T* infer 1
T* infer 1 result = int
T* infer 2
T* infer 2 result = int
T* infer_binary + int int
T* unify int int
T* after unify int int
T* infer (1 + 2) result = int
T* unify int int
T* infer (-(1 + 2)) result = int
T* infer_binary * int int
T* unify int int
T* infer (2 * (-(1 + 2))) result = int
infer    > int
expected > int
[32m.[0mtext> fn x -> fn y -> x + y
T* infer (fn x -> (fn y -> (x + y)))
T* infer Fn (x, (fn y -> (x + y)))
T* infer x ... arg type = '120
T* infer x ... arg ts = { vars:[] body:'120}
T* infer (fn y -> (x + y))
T* infer Fn (y, (x + y))
T* infer y ... arg type = '121
T* infer y ... arg ts = { vars:[] body:'121}
T* infer (x + y)
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'120}
T* infer Ident x ... ts alpha = { vars:[] body:'120}
T* infer x result = '120
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:'121}
T* infer Ident y ... ts alpha = { vars:[] body:'121}
T* infer y result = '121
T* infer_binary + 'a 'a
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* after unify 'a 'a
T* infer (x + y) result = '121!
T* after infer '121!
T* infer (fn y -> (x + y)) result = '121 -> '121!
T* after infer '121 -> '121!
T* infer (fn x -> (fn y -> (x + y))) result = '121! -> '121 -> '121!
infer    > 'a -> 'a -> 'a
expected > 'a -> 'a -> 'a
[32m.[0mtext> (fn x -> x) 1
T* infer ((fn x -> x) 1)
T* infer (fn x -> x)
T* infer Fn (x, x)
T* infer x ... arg type = '122
T* infer x ... arg ts = { vars:[] body:'122}
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'122}
T* infer Ident x ... ts alpha = { vars:[] body:'122}
T* infer x result = '122
T* after infer '122
T* infer (fn x -> x) result = '122 -> '122
T* infer 1
T* infer 1 result = int
T* unify 'a -> 'a int -> 'a
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify int 'a
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer ((fn x -> x) 1) result = int!
infer    > int
expected > int
[32m.[0mtext> (fn x -> x) 1==1
T* infer (((fn x -> x) 1) == 1)
T* infer ((fn x -> x) 1)
T* infer (fn x -> x)
T* infer Fn (x, x)
T* infer x ... arg type = '124
T* infer x ... arg ts = { vars:[] body:'124}
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'124}
T* infer Ident x ... ts alpha = { vars:[] body:'124}
T* infer x result = '124
T* after infer '124
T* infer (fn x -> x) result = '124 -> '124
T* infer 1
T* infer 1 result = int
T* unify 'a -> 'a int -> 'a
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify int 'a
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer ((fn x -> x) 1) result = int!
T* infer 1
T* infer 1 result = int
T* infer_binary == int int
T* unify int int
T* unify int int
T* infer (((fn x -> x) 1) == 1) result = bool
infer    > bool
expected > bool
[32m.[0mtext> (fn _ -> 1) 'a'
T* infer ((fn _ -> 1) 'a')
T* infer (fn _ -> 1)
T* infer 1
T* infer 1 result = int
T* infer (fn _ -> 1) result = '126 -> int
T* infer 'a'
T* infer 'a' result = char
T* unify 'a -> int char -> 'a
T* unify 'a char
T* unify result 'a ... 
T* ... char
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer ((fn _ -> 1) 'a') result = int!
infer    > int
expected > int
[32m.[0mtext> (fn _ -> 2) 3
T* infer ((fn _ -> 2) 3)
T* infer (fn _ -> 2)
T* infer 2
T* infer 2 result = int
T* infer (fn _ -> 2) result = '128 -> int
T* infer 3
T* infer 3 result = int
T* unify 'a -> int int -> 'a
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer ((fn _ -> 2) 3) result = int!
infer    > int
expected > int
[32m.[0mtext> []
T* infer []
T* infer [] result = ['130]
infer    > ['a]
expected > ['a]
[32m.[0mtext> [1,2,3]
T* infer (1 : (2 : (3 : [])))
T* infer 1
T* infer 1 result = int
T* infer (2 : (3 : []))
T* infer 2
T* infer 2 result = int
T* infer (3 : [])
T* infer 3
T* infer 3 result = int
T* infer []
T* infer [] result = ['131]
T* infer_binary : int ['a]
T* unify [int] ['a]
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (3 : []) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (2 : (3 : [])) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (1 : (2 : (3 : []))) result = [int]
infer    > [int]
expected > [int]
[32m.[0mtext> 1:2:[]
T* infer (1 : (2 : []))
T* infer 1
T* infer 1 result = int
T* infer (2 : [])
T* infer 2
T* infer 2 result = int
T* infer []
T* infer [] result = ['132]
T* infer_binary : int ['a]
T* unify [int] ['a]
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (2 : []) result = [int]
T* infer_binary : int [int]
T* unify [int] [int]
T* unify int int
T* infer (1 : (2 : [])) result = [int]
infer    > [int]
expected > [int]
[32m.[0mtext> ['a','b']
T* infer ('a' : ('b' : []))
T* infer 'a'
T* infer 'a' result = char
T* infer ('b' : [])
T* infer 'b'
T* infer 'b' result = char
T* infer []
T* infer [] result = ['133]
T* infer_binary : char ['a]
T* unify [char] ['a]
T* unify char 'a
T* unify result 'a ... 
T* ... char
T* infer ('b' : []) result = [char]
T* infer_binary : char [char]
T* unify [char] [char]
T* unify char char
T* infer ('a' : ('b' : [])) result = [char]
infer    > [char]
expected > [char]
[32m.[0mtext> (fn x -> x)
T* infer (fn x -> x)
T* infer Fn (x, x)
T* infer x ... arg type = '134
T* infer x ... arg ts = { vars:[] body:'134}
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'134}
T* infer Ident x ... ts alpha = { vars:[] body:'134}
T* infer x result = '134
T* after infer '134
T* infer (fn x -> x) result = '134 -> '134
infer    > 'a -> 'a
expected > 'a -> 'a
[32m.[0mtext> fn x -> fn y -> x
T* infer (fn x -> (fn y -> x))
T* infer Fn (x, (fn y -> x))
T* infer x ... arg type = '135
T* infer x ... arg ts = { vars:[] body:'135}
T* infer (fn y -> x)
T* infer Fn (y, x)
T* infer y ... arg type = '136
T* infer y ... arg ts = { vars:[] body:'136}
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'135}
T* infer Ident x ... ts alpha = { vars:[] body:'135}
T* infer x result = '135
T* after infer '135
T* infer (fn y -> x) result = '136 -> '135
T* after infer '136 -> '135
T* infer (fn x -> (fn y -> x)) result = '135 -> '136 -> '135
infer    > 'a -> 'b -> 'a
expected > 'a -> 'b -> 'a
[32m.[0mtext> fn x -> fn y -> y
T* infer (fn x -> (fn y -> y))
T* infer Fn (x, (fn y -> y))
T* infer x ... arg type = '137
T* infer x ... arg ts = { vars:[] body:'137}
T* infer (fn y -> y)
T* infer Fn (y, y)
T* infer y ... arg type = '138
T* infer y ... arg ts = { vars:[] body:'138}
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:'138}
T* infer Ident y ... ts alpha = { vars:[] body:'138}
T* infer y result = '138
T* after infer '138
T* infer (fn y -> y) result = '138 -> '138
T* after infer '138 -> '138
T* infer (fn x -> (fn y -> y)) result = '137 -> '138 -> '138
infer    > 'a -> 'b -> 'b
expected > 'a -> 'b -> 'b
[32m.[0mtext> (fn x -> x + 1) 2 + (fn x -> x + -1) 3
T* infer (((fn x -> (x + 1)) 2) + ((fn x -> (x + (-1))) 3))
T* infer ((fn x -> (x + 1)) 2)
T* infer (fn x -> (x + 1))
T* infer Fn (x, (x + 1))
T* infer x ... arg type = '139
T* infer x ... arg ts = { vars:[] body:'139}
T* infer (x + 1)
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'139}
T* infer Ident x ... ts alpha = { vars:[] body:'139}
T* infer x result = '139
T* infer 1
T* infer 1 result = int
T* infer_binary + 'a int
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* after unify int int
T* infer (x + 1) result = int!
T* after infer int!
T* infer (fn x -> (x + 1)) result = int! -> int!
T* infer 2
T* infer 2 result = int
T* unify int -> int int -> 'a
T* unify int int
T* unify int int
T* unify int 'a
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer ((fn x -> (x + 1)) 2) result = int!
T* infer ((fn x -> (x + (-1))) 3)
T* infer (fn x -> (x + (-1)))
T* infer Fn (x, (x + (-1)))
T* infer x ... arg type = '141
T* infer x ... arg ts = { vars:[] body:'141}
T* infer (x + (-1))
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'141}
T* infer Ident x ... ts alpha = { vars:[] body:'141}
T* infer x result = '141
T* infer (-1)
T* infer 1
T* infer 1 result = int
T* unify int int
T* infer (-1) result = int
T* infer_binary + 'a int
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* after unify int int
T* infer (x + (-1)) result = int!
T* after infer int!
T* infer (fn x -> (x + (-1))) result = int! -> int!
T* infer 3
T* infer 3 result = int
T* unify int -> int int -> 'a
T* unify int int
T* unify int int
T* unify int 'a
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer ((fn x -> (x + (-1))) 3) result = int!
T* infer_binary + int int
T* unify int int
T* unify int int
T* unify int int
T* after unify int int
T* infer (((fn x -> (x + 1)) 2) + ((fn x -> (x + (-1))) 3)) result = int!
infer    > int
expected > int
[32m.[0mtext> fn f -> fn g -> fn x -> g (f x)
T* infer (fn f -> (fn g -> (fn x -> (g (f x)))))
T* infer Fn (f, (fn g -> (fn x -> (g (f x)))))
T* infer f ... arg type = '143
T* infer f ... arg ts = { vars:[] body:'143}
T* infer (fn g -> (fn x -> (g (f x))))
T* infer Fn (g, (fn x -> (g (f x))))
T* infer g ... arg type = '144
T* infer g ... arg ts = { vars:[] body:'144}
T* infer (fn x -> (g (f x)))
T* infer Fn (x, (g (f x)))
T* infer x ... arg type = '145
T* infer x ... arg ts = { vars:[] body:'145}
T* infer (g (f x))
T* infer g
T* infer Ident g
T* infer Ident g ... type schema is { vars:[] body:'144}
T* infer Ident g ... ts alpha = { vars:[] body:'144}
T* infer g result = '144
T* infer (f x)
T* infer f
T* infer Ident f
T* infer Ident f ... type schema is { vars:[] body:'143}
T* infer Ident f ... ts alpha = { vars:[] body:'143}
T* infer f result = '143
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'145}
T* infer Ident x ... ts alpha = { vars:[] body:'145}
T* infer x result = '145
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (f x) result = '146
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (g (f x)) result = '147
T* after infer '147
T* infer (fn x -> (g (f x))) result = '145 -> '147
T* after infer '145 -> '147
T* infer (fn g -> (fn x -> (g (f x)))) result = ('146 -> '147)! -> '145 -> '147
T* after infer ('146 -> '147)! -> '145 -> '147
T* infer (fn f -> (fn g -> (fn x -> (g (f x))))) result = ('145 -> '146)! -> ('146 -> '147)! -> '145 -> '147
infer    > ('a -> 'b) -> ('b -> 'c) -> 'a -> 'c
expected > ('a -> 'b) -> ('b -> 'c) -> 'a -> 'c
[32m.[0mtext> fn x -> fn y -> fn z -> x z (y z)
T* infer (fn x -> (fn y -> (fn z -> ((x z) (y z)))))
T* infer Fn (x, (fn y -> (fn z -> ((x z) (y z)))))
T* infer x ... arg type = '148
T* infer x ... arg ts = { vars:[] body:'148}
T* infer (fn y -> (fn z -> ((x z) (y z))))
T* infer Fn (y, (fn z -> ((x z) (y z))))
T* infer y ... arg type = '149
T* infer y ... arg ts = { vars:[] body:'149}
T* infer (fn z -> ((x z) (y z)))
T* infer Fn (z, ((x z) (y z)))
T* infer z ... arg type = '150
T* infer z ... arg ts = { vars:[] body:'150}
T* infer ((x z) (y z))
T* infer (x z)
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'148}
T* infer Ident x ... ts alpha = { vars:[] body:'148}
T* infer x result = '148
T* infer z
T* infer Ident z
T* infer Ident z ... type schema is { vars:[] body:'150}
T* infer Ident z ... ts alpha = { vars:[] body:'150}
T* infer z result = '150
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (x z) result = '151
T* infer (y z)
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:'149}
T* infer Ident y ... ts alpha = { vars:[] body:'149}
T* infer y result = '149
T* infer z
T* infer Ident z
T* infer Ident z ... type schema is { vars:[] body:'150}
T* infer Ident z ... ts alpha = { vars:[] body:'150}
T* infer z result = '150
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (y z) result = '152
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer ((x z) (y z)) result = '153
T* after infer '153
T* infer (fn z -> ((x z) (y z))) result = '150 -> '153
T* after infer '150 -> '153
T* infer (fn y -> (fn z -> ((x z) (y z)))) result = ('150 -> '152)! -> '150 -> '153
T* after infer ('150 -> '152)! -> '150 -> '153
T* infer (fn x -> (fn y -> (fn z -> ((x z) (y z))))) result = ('150 -> '152 -> '153!)! -> ('150 -> '152)! -> '150 -> '153
infer    > ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c
expected > ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c
[32m.[0mtext> fn x -> {let y = x + 1; x}
T* infer (fn x -> {(let y = (x + 1)); x; })
T* infer Fn (x, {(let y = (x + 1)); x; })
T* infer x ... arg type = '154
T* infer x ... arg ts = { vars:[] body:'154}
T* infer {(let y = (x + 1)); x; }
T* infer (let y = (x + 1))
T* infer let y = (x + 1)
T* infer (x + 1)
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'154}
T* infer Ident x ... ts alpha = { vars:[] body:'154}
T* infer x result = '154
T* infer 1
T* infer 1 result = int
T* infer_binary + 'a int
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* after unify int int
T* infer (x + 1) result = int!
T* after infer int!
T* poly type = { vars:[] body:int}
T* infer (let y = (x + 1)) result = unit
T* unify unit unit
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:int!}
T* infer Ident x ... ts alpha = { vars:[] body:int}
T* infer x result = int
T* infer {(let y = (x + 1)); x; } result = int
T* after infer int
T* infer (fn x -> {(let y = (x + 1)); x; }) result = int! -> int
infer    > int -> int
expected > int -> int
[32m.[0mtext> fn x -> {let y = x + 1; y}
T* infer (fn x -> {(let y = (x + 1)); y; })
T* infer Fn (x, {(let y = (x + 1)); y; })
T* infer x ... arg type = '155
T* infer x ... arg ts = { vars:[] body:'155}
T* infer {(let y = (x + 1)); y; }
T* infer (let y = (x + 1))
T* infer let y = (x + 1)
T* infer (x + 1)
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'155}
T* infer Ident x ... ts alpha = { vars:[] body:'155}
T* infer x result = '155
T* infer 1
T* infer 1 result = int
T* infer_binary + 'a int
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* after unify int int
T* infer (x + 1) result = int!
T* after infer int!
T* poly type = { vars:[] body:int}
T* infer (let y = (x + 1)) result = unit
T* unify unit unit
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:int}
T* infer Ident y ... ts alpha = { vars:[] body:int}
T* infer y result = int
T* infer {(let y = (x + 1)); y; } result = int
T* after infer int
T* infer (fn x -> {(let y = (x + 1)); y; }) result = int! -> int
infer    > int -> int
expected > int -> int
[32m.[0mtext> fn b -> fn x -> if x b then x else (fn x -> b)
T* infer (fn b -> (fn x -> (if (x b) then x else (fn x -> b))))
T* infer Fn (b, (fn x -> (if (x b) then x else (fn x -> b))))
T* infer b ... arg type = '156
T* infer b ... arg ts = { vars:[] body:'156}
T* infer (fn x -> (if (x b) then x else (fn x -> b)))
T* infer Fn (x, (if (x b) then x else (fn x -> b)))
T* infer x ... arg type = '157
T* infer x ... arg ts = { vars:[] body:'157}
T* infer (if (x b) then x else (fn x -> b))
T* infer If (x b) then x else (fn x -> b)
T* infer (x b)
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'157}
T* infer Ident x ... ts alpha = { vars:[] body:'157}
T* infer x result = '157
T* infer b
T* infer Ident b
T* infer Ident b ... type schema is { vars:[] body:'156}
T* infer Ident b ... ts alpha = { vars:[] body:'156}
T* infer b result = '156
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (x b) result = '158
T* unify bool 'a
T* unify result 'a ... 
T* ... bool
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'156 -> bool!!}
T* infer Ident x ... ts alpha = { vars:[] body:'156 -> bool}
T* infer x result = '156 -> bool
T* infer (fn x -> b)
T* infer Fn (x, b)
T* infer x ... arg type = '159
T* infer x ... arg ts = { vars:[] body:'159}
T* infer b
T* infer Ident b
T* infer Ident b ... type schema is { vars:[] body:'156}
T* infer Ident b ... ts alpha = { vars:[] body:'156}
T* infer b result = '156
T* after infer '156
T* infer (fn x -> b) result = '159 -> '156
T* unify 'a -> bool 'a -> 'b
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* unify bool 'a
T* unify bool 'a
T* unify result 'a ... 
T* ... bool
T* infer (if (x b) then x else (fn x -> b)) result = bool!! -> bool
T* after infer bool!! -> bool
T* infer (fn x -> (if (x b) then x else (fn x -> b))) result = (bool!! -> bool!)! -> bool!! -> bool
T* after infer (bool!! -> bool!)! -> bool!! -> bool
T* infer (fn b -> (fn x -> (if (x b) then x else (fn x -> b)))) result = bool!! -> (bool!! -> bool!)! -> bool!! -> bool
infer    > bool -> (bool -> bool) -> bool -> bool
expected > bool -> (bool -> bool) -> bool -> bool
[32m.[0mtext> fn x -> if true then x else (if x then true else false)
T* infer (fn x -> (if true then x else (if x then true else false)))
T* infer Fn (x, (if true then x else (if x then true else false)))
T* infer x ... arg type = '160
T* infer x ... arg ts = { vars:[] body:'160}
T* infer (if true then x else (if x then true else false))
T* infer If true then x else (if x then true else false)
T* infer true
T* infer true result = bool
T* unify bool bool
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'160}
T* infer Ident x ... ts alpha = { vars:[] body:'160}
T* infer x result = '160
T* infer (if x then true else false)
T* infer If x then true else false
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'160}
T* infer Ident x ... ts alpha = { vars:[] body:'160}
T* infer x result = '160
T* unify bool 'a
T* unify result 'a ... 
T* ... bool
T* infer true
T* infer true result = bool
T* infer false
T* infer false result = bool
T* unify bool bool
T* infer (if x then true else false) result = bool
T* unify bool bool
T* unify bool bool
T* infer (if true then x else (if x then true else false)) result = bool!
T* after infer bool!
T* infer (fn x -> (if true then x else (if x then true else false))) result = bool! -> bool!
infer    > bool -> bool
expected > bool -> bool
[32m.[0mtext> fn x -> fn y -> if x then x else y
T* infer (fn x -> (fn y -> (if x then x else y)))
T* infer Fn (x, (fn y -> (if x then x else y)))
T* infer x ... arg type = '161
T* infer x ... arg ts = { vars:[] body:'161}
T* infer (fn y -> (if x then x else y))
T* infer Fn (y, (if x then x else y))
T* infer y ... arg type = '162
T* infer y ... arg ts = { vars:[] body:'162}
T* infer (if x then x else y)
T* infer If x then x else y
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'161}
T* infer Ident x ... ts alpha = { vars:[] body:'161}
T* infer x result = '161
T* unify bool 'a
T* unify result 'a ... 
T* ... bool
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:bool!}
T* infer Ident x ... ts alpha = { vars:[] body:bool}
T* infer x result = bool
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:'162}
T* infer Ident y ... ts alpha = { vars:[] body:'162}
T* infer y result = '162
T* unify bool 'a
T* unify result 'a ... 
T* ... bool
T* infer (if x then x else y) result = bool
T* after infer bool
T* infer (fn y -> (if x then x else y)) result = bool! -> bool
T* after infer bool! -> bool
T* infer (fn x -> (fn y -> (if x then x else y))) result = bool! -> bool! -> bool
infer    > bool -> bool -> bool
expected > bool -> bool -> bool
[32m.[0mtext> fn n -> (fn x -> x (fn y -> y)) (fn f -> f n)
T* infer (fn n -> ((fn x -> (x (fn y -> y))) (fn f -> (f n))))
T* infer Fn (n, ((fn x -> (x (fn y -> y))) (fn f -> (f n))))
T* infer n ... arg type = '163
T* infer n ... arg ts = { vars:[] body:'163}
T* infer ((fn x -> (x (fn y -> y))) (fn f -> (f n)))
T* infer (fn x -> (x (fn y -> y)))
T* infer Fn (x, (x (fn y -> y)))
T* infer x ... arg type = '164
T* infer x ... arg ts = { vars:[] body:'164}
T* infer (x (fn y -> y))
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'164}
T* infer Ident x ... ts alpha = { vars:[] body:'164}
T* infer x result = '164
T* infer (fn y -> y)
T* infer Fn (y, y)
T* infer y ... arg type = '165
T* infer y ... arg ts = { vars:[] body:'165}
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:'165}
T* infer Ident y ... ts alpha = { vars:[] body:'165}
T* infer y result = '165
T* after infer '165
T* infer (fn y -> y) result = '165 -> '165
T* unify 'a ('a -> 'a) -> 'b
T* unify result 'a ... 
T* ... ('a -> 'a) -> 'b
T* infer (x (fn y -> y)) result = '166
T* after infer '166
T* infer (fn x -> (x (fn y -> y))) result = (('165 -> '165) -> '166)! -> '166
T* infer (fn f -> (f n))
T* infer Fn (f, (f n))
T* infer f ... arg type = '167
T* infer f ... arg ts = { vars:[] body:'167}
T* infer (f n)
T* infer f
T* infer Ident f
T* infer Ident f ... type schema is { vars:[] body:'167}
T* infer Ident f ... ts alpha = { vars:[] body:'167}
T* infer f result = '167
T* infer n
T* infer Ident n
T* infer Ident n ... type schema is { vars:[] body:'163}
T* infer Ident n ... ts alpha = { vars:[] body:'163}
T* infer n result = '163
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (f n) result = '168
T* after infer '168
T* infer (fn f -> (f n)) result = ('163 -> '168)! -> '168
T* unify (('a -> 'a) -> 'b) -> 'b (('a -> 'b) -> 'b) -> 'c
T* unify ('a -> 'a) -> 'b ('a -> 'b) -> 'b
T* unify ('a -> 'a) -> 'b ('a -> 'b) -> 'b
T* unify 'a -> 'a 'a -> 'b
T* unify 'a -> 'a 'a -> 'b
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* unify 'a 'a
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* unify 'a 'a
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* infer ((fn x -> (x (fn y -> y))) (fn f -> (f n))) result = '169
T* after infer '169
T* infer (fn n -> ((fn x -> (x (fn y -> y))) (fn f -> (f n)))) result = '169!! -> '169
infer    > 'a -> 'a
expected > 'a -> 'a
[32m.[0mtext> fn x -> fn y -> x y
T* infer (fn x -> (fn y -> (x y)))
T* infer Fn (x, (fn y -> (x y)))
T* infer x ... arg type = '170
T* infer x ... arg ts = { vars:[] body:'170}
T* infer (fn y -> (x y))
T* infer Fn (y, (x y))
T* infer y ... arg type = '171
T* infer y ... arg ts = { vars:[] body:'171}
T* infer (x y)
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'170}
T* infer Ident x ... ts alpha = { vars:[] body:'170}
T* infer x result = '170
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:'171}
T* infer Ident y ... ts alpha = { vars:[] body:'171}
T* infer y result = '171
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (x y) result = '172
T* after infer '172
T* infer (fn y -> (x y)) result = '171 -> '172
T* after infer '171 -> '172
T* infer (fn x -> (fn y -> (x y))) result = ('171 -> '172)! -> '171 -> '172
infer    > ('a -> 'b) -> 'a -> 'b
expected > ('a -> 'b) -> 'a -> 'b
[32m.[0mtext> fn x -> fn y -> x (y x)
T* infer (fn x -> (fn y -> (x (y x))))
T* infer Fn (x, (fn y -> (x (y x))))
T* infer x ... arg type = '173
T* infer x ... arg ts = { vars:[] body:'173}
T* infer (fn y -> (x (y x)))
T* infer Fn (y, (x (y x)))
T* infer y ... arg type = '174
T* infer y ... arg ts = { vars:[] body:'174}
T* infer (x (y x))
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'173}
T* infer Ident x ... ts alpha = { vars:[] body:'173}
T* infer x result = '173
T* infer (y x)
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:'174}
T* infer Ident y ... ts alpha = { vars:[] body:'174}
T* infer y result = '174
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'173}
T* infer Ident x ... ts alpha = { vars:[] body:'173}
T* infer x result = '173
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (y x) result = '175
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (x (y x)) result = '176
T* after infer '176
T* infer (fn y -> (x (y x))) result = (('175 -> '176)! -> '175)! -> '176
T* after infer (('175 -> '176)! -> '175)! -> '176
T* infer (fn x -> (fn y -> (x (y x)))) result = ('175 -> '176)! -> (('175 -> '176)! -> '175)! -> '176
infer    > ('a -> 'b) -> (('a -> 'b) -> 'a) -> 'b
expected > ('a -> 'b) -> (('a -> 'b) -> 'a) -> 'b
[32m.[0mtext> fn x -> fn y -> x (y x) (y x)
T* infer (fn x -> (fn y -> ((x (y x)) (y x))))
T* infer Fn (x, (fn y -> ((x (y x)) (y x))))
T* infer x ... arg type = '177
T* infer x ... arg ts = { vars:[] body:'177}
T* infer (fn y -> ((x (y x)) (y x)))
T* infer Fn (y, ((x (y x)) (y x)))
T* infer y ... arg type = '178
T* infer y ... arg ts = { vars:[] body:'178}
T* infer ((x (y x)) (y x))
T* infer (x (y x))
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'177}
T* infer Ident x ... ts alpha = { vars:[] body:'177}
T* infer x result = '177
T* infer (y x)
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:'178}
T* infer Ident y ... ts alpha = { vars:[] body:'178}
T* infer y result = '178
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'177}
T* infer Ident x ... ts alpha = { vars:[] body:'177}
T* infer x result = '177
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (y x) result = '179
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (x (y x)) result = '180
T* infer (y x)
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:('179 -> '180)! -> '179!}
T* infer Ident y ... ts alpha = { vars:[] body:('179 -> '180) -> '179}
T* infer y result = ('179 -> '180) -> '179
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'179 -> '180!}
T* infer Ident x ... ts alpha = { vars:[] body:'179 -> '180}
T* infer x result = '179 -> '180
T* unify ('a -> 'b) -> 'a ('a -> 'b) -> 'c
T* unify 'a -> 'b 'a -> 'b
T* unify 'a 'a
T* unify 'a 'a
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* infer (y x) result = '181
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer ((x (y x)) (y x)) result = '182
T* after infer '182
T* infer (fn y -> ((x (y x)) (y x))) result = (('181! -> '181 -> '182!)! -> '181!)! -> '182
T* after infer (('181! -> '181 -> '182!)! -> '181!)! -> '182
T* infer (fn x -> (fn y -> ((x (y x)) (y x)))) result = ('181! -> '181 -> '182!)! -> (('181! -> '181 -> '182!)! -> '181!)! -> '182
infer    > ('a -> 'a -> 'b) -> (('a -> 'a -> 'b) -> 'a) -> 'b
expected > ('a -> 'a -> 'b) -> (('a -> 'a -> 'b) -> 'a) -> 'b
[32m.[0mtext> fn x -> fn y -> fn z -> x (z x) (y (z x y))
T* infer (fn x -> (fn y -> (fn z -> ((x (z x)) (y ((z x) y))))))
T* infer Fn (x, (fn y -> (fn z -> ((x (z x)) (y ((z x) y))))))
T* infer x ... arg type = '183
T* infer x ... arg ts = { vars:[] body:'183}
T* infer (fn y -> (fn z -> ((x (z x)) (y ((z x) y)))))
T* infer Fn (y, (fn z -> ((x (z x)) (y ((z x) y)))))
T* infer y ... arg type = '184
T* infer y ... arg ts = { vars:[] body:'184}
T* infer (fn z -> ((x (z x)) (y ((z x) y))))
T* infer Fn (z, ((x (z x)) (y ((z x) y))))
T* infer z ... arg type = '185
T* infer z ... arg ts = { vars:[] body:'185}
T* infer ((x (z x)) (y ((z x) y)))
T* infer (x (z x))
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'183}
T* infer Ident x ... ts alpha = { vars:[] body:'183}
T* infer x result = '183
T* infer (z x)
T* infer z
T* infer Ident z
T* infer Ident z ... type schema is { vars:[] body:'185}
T* infer Ident z ... ts alpha = { vars:[] body:'185}
T* infer z result = '185
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'183}
T* infer Ident x ... ts alpha = { vars:[] body:'183}
T* infer x result = '183
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (z x) result = '186
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (x (z x)) result = '187
T* infer (y ((z x) y))
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:'184}
T* infer Ident y ... ts alpha = { vars:[] body:'184}
T* infer y result = '184
T* infer ((z x) y)
T* infer (z x)
T* infer z
T* infer Ident z
T* infer Ident z ... type schema is { vars:[] body:('186 -> '187)! -> '186!}
T* infer Ident z ... ts alpha = { vars:[] body:('186 -> '187) -> '186}
T* infer z result = ('186 -> '187) -> '186
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'186 -> '187!}
T* infer Ident x ... ts alpha = { vars:[] body:'186 -> '187}
T* infer x result = '186 -> '187
T* unify ('a -> 'b) -> 'a ('a -> 'b) -> 'c
T* unify 'a -> 'b 'a -> 'b
T* unify 'a 'a
T* unify 'a 'a
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* infer (z x) result = '188
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:'184}
T* infer Ident y ... ts alpha = { vars:[] body:'184}
T* infer y result = '184
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer ((z x) y) result = '189
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (y ((z x) y)) result = '190
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer ((x (z x)) (y ((z x) y))) result = '191
T* after infer '191
T* infer (fn z -> ((x (z x)) (y ((z x) y)))) result = (((('189 -> '190)! -> '189)!! -> '190 -> '191!)! -> ('189 -> '190)! -> '189!!)! -> '191
T* after infer (((('189 -> '190)! -> '189)!! -> '190 -> '191!)! -> ('189 -> '190)! -> '189!!)! -> '191
T* infer (fn y -> (fn z -> ((x (z x)) (y ((z x) y))))) result = ('189 -> '190)! -> (((('189 -> '190)! -> '189)!! -> '190 -> '191!)! -> ('189 -> '190)! -> '189!!)! -> '191
T* after infer ('189 -> '190)! -> (((('189 -> '190)! -> '189)!! -> '190 -> '191!)! -> ('189 -> '190)! -> '189!!)! -> '191
T* infer (fn x -> (fn y -> (fn z -> ((x (z x)) (y ((z x) y)))))) result = ((('189 -> '190)! -> '189)!! -> '190 -> '191!)! -> ('189 -> '190)! -> (((('189 -> '190)! -> '189)!! -> '190 -> '191!)! -> ('189 -> '190)! -> '189!!)! -> '191
infer    > ((('a -> 'b) -> 'a) -> 'b -> 'c) -> ('a -> 'b) -> (((('a -> 'b) -> 'a) -> 'b -> 'c) -> ('a -> 'b) -> 'a) -> 'c
expected > ((('a -> 'b) -> 'a) -> 'b -> 'c) -> ('a -> 'b) -> (((('a -> 'b) -> 'a) -> 'b -> 'c) -> ('a -> 'b) -> 'a) -> 'c
[32m.[0mtext> { let id = fn x -> x; let f = fn y -> id (y id); f}
T* infer {(let id = (fn x -> x)); (let f = (fn y -> (id (y id)))); f; }
T* infer (let id = (fn x -> x))
T* infer let id = (fn x -> x)
T* infer (fn x -> x)
T* infer Fn (x, x)
T* infer x ... arg type = '192
T* infer x ... arg ts = { vars:[] body:'192}
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'192}
T* infer Ident x ... ts alpha = { vars:[] body:'192}
T* infer x result = '192
T* after infer '192
T* infer (fn x -> x) result = '192 -> '192
T* after infer '192 -> '192
T* poly type = { vars:[192] body:'192 -> '192}
T* infer (let id = (fn x -> x)) result = unit
T* unify unit unit
T* infer (let f = (fn y -> (id (y id))))
T* infer let f = (fn y -> (id (y id)))
T* infer (fn y -> (id (y id)))
T* infer Fn (y, (id (y id)))
T* infer y ... arg type = '193
T* infer y ... arg ts = { vars:[] body:'193}
T* infer (id (y id))
T* infer id
T* infer Ident id
T* infer Ident id ... type schema is { vars:[192] body:'192 -> '192}
T* infer Ident id ... ts alpha = { vars:[194] body:'194 -> '194}
T* infer id result = '194 -> '194
T* infer (y id)
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:'193}
T* infer Ident y ... ts alpha = { vars:[] body:'193}
T* infer y result = '193
T* infer id
T* infer Ident id
T* infer Ident id ... type schema is { vars:[192] body:'192 -> '192}
T* infer Ident id ... ts alpha = { vars:[195] body:'195 -> '195}
T* infer id result = '195 -> '195
T* unify 'a ('a -> 'a) -> 'b
T* unify result 'a ... 
T* ... ('a -> 'a) -> 'b
T* infer (y id) result = '196
T* unify 'a -> 'a 'a -> 'b
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* unify 'a 'a
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* infer (id (y id)) result = '197
T* after infer '197
T* infer (fn y -> (id (y id))) result = (('195 -> '195) -> '197!)! -> '197
T* after infer (('195 -> '195) -> '197!)! -> '197
T* poly type = { vars:[197,195] body:(('195 -> '195) -> '197) -> '197}
T* infer (let f = (fn y -> (id (y id)))) result = unit
T* unify unit unit
T* infer f
T* infer Ident f
T* infer Ident f ... type schema is { vars:[197,195] body:(('195 -> '195) -> '197) -> '197}
T* infer Ident f ... ts alpha = { vars:[198,199] body:(('199 -> '199) -> '198) -> '198}
T* infer f result = (('199 -> '199) -> '198) -> '198
T* infer {(let id = (fn x -> x)); (let f = (fn y -> (id (y id)))); f; } result = (('199 -> '199) -> '198) -> '198
infer    > (('a -> 'a) -> 'b) -> 'b
expected > (('a -> 'a) -> 'b) -> 'b
[32m.[0mtext> { let k = fn x -> fn y -> x; let k1 = fn x -> fn y -> k (x k); k1 }
T* infer {(let k = (fn x -> (fn y -> x))); (let k1 = (fn x -> (fn y -> (k (x k))))); k1; }
T* infer (let k = (fn x -> (fn y -> x)))
T* infer let k = (fn x -> (fn y -> x))
T* infer (fn x -> (fn y -> x))
T* infer Fn (x, (fn y -> x))
T* infer x ... arg type = '200
T* infer x ... arg ts = { vars:[] body:'200}
T* infer (fn y -> x)
T* infer Fn (y, x)
T* infer y ... arg type = '201
T* infer y ... arg ts = { vars:[] body:'201}
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'200}
T* infer Ident x ... ts alpha = { vars:[] body:'200}
T* infer x result = '200
T* after infer '200
T* infer (fn y -> x) result = '201 -> '200
T* after infer '201 -> '200
T* infer (fn x -> (fn y -> x)) result = '200 -> '201 -> '200
T* after infer '200 -> '201 -> '200
T* poly type = { vars:[201,200] body:'200 -> '201 -> '200}
T* infer (let k = (fn x -> (fn y -> x))) result = unit
T* unify unit unit
T* infer (let k1 = (fn x -> (fn y -> (k (x k)))))
T* infer let k1 = (fn x -> (fn y -> (k (x k))))
T* infer (fn x -> (fn y -> (k (x k))))
T* infer Fn (x, (fn y -> (k (x k))))
T* infer x ... arg type = '202
T* infer x ... arg ts = { vars:[] body:'202}
T* infer (fn y -> (k (x k)))
T* infer Fn (y, (k (x k)))
T* infer y ... arg type = '203
T* infer y ... arg ts = { vars:[] body:'203}
T* infer (k (x k))
T* infer k
T* infer Ident k
T* infer Ident k ... type schema is { vars:[201,200] body:'200 -> '201 -> '200}
T* infer Ident k ... ts alpha = { vars:[204,205] body:'205 -> '204 -> '205}
T* infer k result = '205 -> '204 -> '205
T* infer (x k)
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'202}
T* infer Ident x ... ts alpha = { vars:[] body:'202}
T* infer x result = '202
T* infer k
T* infer Ident k
T* infer Ident k ... type schema is { vars:[201,200] body:'200 -> '201 -> '200}
T* infer Ident k ... ts alpha = { vars:[206,207] body:'207 -> '206 -> '207}
T* infer k result = '207 -> '206 -> '207
T* unify 'a ('a -> 'b -> 'a) -> 'c
T* unify result 'a ... 
T* ... ('a -> 'b -> 'a) -> 'c
T* infer (x k) result = '208
T* unify 'a -> 'b -> 'a 'a -> 'b
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* unify 'a -> 'b 'a
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (k (x k)) result = '204 -> '208!!
T* after infer '204 -> '208!!
T* infer (fn y -> (k (x k))) result = '203 -> '204 -> '208!!
T* after infer '203 -> '204 -> '208!!
T* infer (fn x -> (fn y -> (k (x k)))) result = (('207 -> '206 -> '207) -> '208)! -> '203 -> '204 -> '208!!
T* after infer (('207 -> '206 -> '207) -> '208)! -> '203 -> '204 -> '208!!
T* poly type = { vars:[204,203,208,206,207] body:(('207 -> '206 -> '207) -> '208) -> '203 -> '204 -> '208}
T* infer (let k1 = (fn x -> (fn y -> (k (x k))))) result = unit
T* unify unit unit
T* infer k1
T* infer Ident k1
T* infer Ident k1 ... type schema is { vars:[204,203,208,206,207] body:(('207 -> '206 -> '207) -> '208) -> '203 -> '204 -> '208}
T* infer Ident k1 ... ts alpha = { vars:[210,211,212,213,214] body:(('214 -> '213 -> '214) -> '212) -> '211 -> '210 -> '212}
T* infer k1 result = (('214 -> '213 -> '214) -> '212) -> '211 -> '210 -> '212
T* infer {(let k = (fn x -> (fn y -> x))); (let k1 = (fn x -> (fn y -> (k (x k))))); k1; } result = (('214 -> '213 -> '214) -> '212) -> '211 -> '210 -> '212
infer    > (('a -> 'b -> 'a) -> 'c) -> 'd -> 'e -> 'c
expected > (('a -> 'b -> 'a) -> 'c) -> 'd -> 'e -> 'c
[32m.[0mtext> { let s = fn x -> fn y -> fn z -> x z (y z); let s1 = fn x -> fn y -> fn z -> x s (z s) (y s (z s)); s1 }
T* infer {(let s = (fn x -> (fn y -> (fn z -> ((x z) (y z)))))); (let s1 = (fn x -> (fn y -> (fn z -> (((x s) (z s)) ((y s) (z s))))))); s1; }
T* infer (let s = (fn x -> (fn y -> (fn z -> ((x z) (y z))))))
T* infer let s = (fn x -> (fn y -> (fn z -> ((x z) (y z)))))
T* infer (fn x -> (fn y -> (fn z -> ((x z) (y z)))))
T* infer Fn (x, (fn y -> (fn z -> ((x z) (y z)))))
T* infer x ... arg type = '215
T* infer x ... arg ts = { vars:[] body:'215}
T* infer (fn y -> (fn z -> ((x z) (y z))))
T* infer Fn (y, (fn z -> ((x z) (y z))))
T* infer y ... arg type = '216
T* infer y ... arg ts = { vars:[] body:'216}
T* infer (fn z -> ((x z) (y z)))
T* infer Fn (z, ((x z) (y z)))
T* infer z ... arg type = '217
T* infer z ... arg ts = { vars:[] body:'217}
T* infer ((x z) (y z))
T* infer (x z)
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'215}
T* infer Ident x ... ts alpha = { vars:[] body:'215}
T* infer x result = '215
T* infer z
T* infer Ident z
T* infer Ident z ... type schema is { vars:[] body:'217}
T* infer Ident z ... ts alpha = { vars:[] body:'217}
T* infer z result = '217
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (x z) result = '218
T* infer (y z)
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:'216}
T* infer Ident y ... ts alpha = { vars:[] body:'216}
T* infer y result = '216
T* infer z
T* infer Ident z
T* infer Ident z ... type schema is { vars:[] body:'217}
T* infer Ident z ... ts alpha = { vars:[] body:'217}
T* infer z result = '217
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (y z) result = '219
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer ((x z) (y z)) result = '220
T* after infer '220
T* infer (fn z -> ((x z) (y z))) result = '217 -> '220
T* after infer '217 -> '220
T* infer (fn y -> (fn z -> ((x z) (y z)))) result = ('217 -> '219)! -> '217 -> '220
T* after infer ('217 -> '219)! -> '217 -> '220
T* infer (fn x -> (fn y -> (fn z -> ((x z) (y z))))) result = ('217 -> '219 -> '220!)! -> ('217 -> '219)! -> '217 -> '220
T* after infer ('217 -> '219 -> '220!)! -> ('217 -> '219)! -> '217 -> '220
T* poly type = { vars:[220,219,217] body:('217 -> '219 -> '220) -> ('217 -> '219) -> '217 -> '220}
T* infer (let s = (fn x -> (fn y -> (fn z -> ((x z) (y z)))))) result = unit
T* unify unit unit
T* infer (let s1 = (fn x -> (fn y -> (fn z -> (((x s) (z s)) ((y s) (z s)))))))
T* infer let s1 = (fn x -> (fn y -> (fn z -> (((x s) (z s)) ((y s) (z s))))))
T* infer (fn x -> (fn y -> (fn z -> (((x s) (z s)) ((y s) (z s))))))
T* infer Fn (x, (fn y -> (fn z -> (((x s) (z s)) ((y s) (z s))))))
T* infer x ... arg type = '221
T* infer x ... arg ts = { vars:[] body:'221}
T* infer (fn y -> (fn z -> (((x s) (z s)) ((y s) (z s)))))
T* infer Fn (y, (fn z -> (((x s) (z s)) ((y s) (z s)))))
T* infer y ... arg type = '222
T* infer y ... arg ts = { vars:[] body:'222}
T* infer (fn z -> (((x s) (z s)) ((y s) (z s))))
T* infer Fn (z, (((x s) (z s)) ((y s) (z s))))
T* infer z ... arg type = '223
T* infer z ... arg ts = { vars:[] body:'223}
T* infer (((x s) (z s)) ((y s) (z s)))
T* infer ((x s) (z s))
T* infer (x s)
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'221}
T* infer Ident x ... ts alpha = { vars:[] body:'221}
T* infer x result = '221
T* infer s
T* infer Ident s
T* infer Ident s ... type schema is { vars:[220,219,217] body:('217 -> '219 -> '220) -> ('217 -> '219) -> '217 -> '220}
T* infer Ident s ... ts alpha = { vars:[224,225,226] body:('226 -> '225 -> '224) -> ('226 -> '225) -> '226 -> '224}
T* infer s result = ('226 -> '225 -> '224) -> ('226 -> '225) -> '226 -> '224
T* unify 'a (('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c) -> 'd
T* unify result 'a ... 
T* ... (('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c) -> 'd
T* infer (x s) result = '227
T* infer (z s)
T* infer z
T* infer Ident z
T* infer Ident z ... type schema is { vars:[] body:'223}
T* infer Ident z ... ts alpha = { vars:[] body:'223}
T* infer z result = '223
T* infer s
T* infer Ident s
T* infer Ident s ... type schema is { vars:[220,219,217] body:('217 -> '219 -> '220) -> ('217 -> '219) -> '217 -> '220}
T* infer Ident s ... ts alpha = { vars:[228,229,230] body:('230 -> '229 -> '228) -> ('230 -> '229) -> '230 -> '228}
T* infer s result = ('230 -> '229 -> '228) -> ('230 -> '229) -> '230 -> '228
T* unify 'a (('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c) -> 'd
T* unify result 'a ... 
T* ... (('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c) -> 'd
T* infer (z s) result = '231
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer ((x s) (z s)) result = '232
T* infer ((y s) (z s))
T* infer (y s)
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:'222}
T* infer Ident y ... ts alpha = { vars:[] body:'222}
T* infer y result = '222
T* infer s
T* infer Ident s
T* infer Ident s ... type schema is { vars:[220,219,217] body:('217 -> '219 -> '220) -> ('217 -> '219) -> '217 -> '220}
T* infer Ident s ... ts alpha = { vars:[233,234,235] body:('235 -> '234 -> '233) -> ('235 -> '234) -> '235 -> '233}
T* infer s result = ('235 -> '234 -> '233) -> ('235 -> '234) -> '235 -> '233
T* unify 'a (('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c) -> 'd
T* unify result 'a ... 
T* ... (('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c) -> 'd
T* infer (y s) result = '236
T* infer (z s)
T* infer z
T* infer Ident z
T* infer Ident z ... type schema is { vars:[] body:(('230 -> '229 -> '228) -> ('230 -> '229) -> '230 -> '228) -> '231!}
T* infer Ident z ... ts alpha = { vars:[] body:(('230 -> '229 -> '228) -> ('230 -> '229) -> '230 -> '228) -> '231}
T* infer z result = (('230 -> '229 -> '228) -> ('230 -> '229) -> '230 -> '228) -> '231
T* infer s
T* infer Ident s
T* infer Ident s ... type schema is { vars:[220,219,217] body:('217 -> '219 -> '220) -> ('217 -> '219) -> '217 -> '220}
T* infer Ident s ... ts alpha = { vars:[237,238,239] body:('239 -> '238 -> '237) -> ('239 -> '238) -> '239 -> '237}
T* infer s result = ('239 -> '238 -> '237) -> ('239 -> '238) -> '239 -> '237
T* unify (('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c) -> 'd (('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c) -> 'd
T* unify ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c
T* unify 'a -> 'b -> 'c 'a -> 'b -> 'c
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* unify 'a -> 'b 'a -> 'b
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* unify ('a -> 'b) -> 'a -> 'c ('a -> 'b) -> 'a -> 'c
T* unify 'a -> 'b 'a -> 'b
T* unify 'a 'a
T* unify 'a 'a
T* unify 'a 'a
T* unify 'a 'a
T* unify 'a -> 'b 'a -> 'b
T* unify 'a 'a
T* unify 'a 'a
T* unify 'a 'a
T* unify 'a 'a
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* infer (z s) result = '240
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer ((y s) (z s)) result = '241
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (((x s) (z s)) ((y s) (z s))) result = '242
T* after infer '242
T* infer (fn z -> (((x s) (z s)) ((y s) (z s)))) result = ((('239! -> '238! -> '237!) -> ('239! -> '238!) -> '239! -> '237!) -> '240!)! -> '242
T* after infer ((('239! -> '238! -> '237!) -> ('239! -> '238!) -> '239! -> '237!) -> '240!)! -> '242
T* infer (fn y -> (fn z -> (((x s) (z s)) ((y s) (z s))))) result = ((('235 -> '234 -> '233) -> ('235 -> '234) -> '235 -> '233) -> '240 -> '241!)! -> ((('239! -> '238! -> '237!) -> ('239! -> '238!) -> '239! -> '237!) -> '240!)! -> '242
T* after infer ((('235 -> '234 -> '233) -> ('235 -> '234) -> '235 -> '233) -> '240 -> '241!)! -> ((('239! -> '238! -> '237!) -> ('239! -> '238!) -> '239! -> '237!) -> '240!)! -> '242
T* infer (fn x -> (fn y -> (fn z -> (((x s) (z s)) ((y s) (z s)))))) result = ((('226 -> '225 -> '224) -> ('226 -> '225) -> '226 -> '224) -> '240! -> '241 -> '242!!)! -> ((('235 -> '234 -> '233) -> ('235 -> '234) -> '235 -> '233) -> '240 -> '241!)! -> ((('239! -> '238! -> '237!) -> ('239! -> '238!) -> '239! -> '237!) -> '240!)! -> '242
T* after infer ((('226 -> '225 -> '224) -> ('226 -> '225) -> '226 -> '224) -> '240! -> '241 -> '242!!)! -> ((('235 -> '234 -> '233) -> ('235 -> '234) -> '235 -> '233) -> '240 -> '241!)! -> ((('239! -> '238! -> '237!) -> ('239! -> '238!) -> '239! -> '237!) -> '240!)! -> '242
T* poly type = { vars:[237,238,239,233,234,235,242,241,240,224,225,226] body:((('226 -> '225 -> '224) -> ('226 -> '225) -> '226 -> '224) -> '240 -> '241 -> '242) -> ((('235 -> '234 -> '233) -> ('235 -> '234) -> '235 -> '233) -> '240 -> '241) -> ((('239 -> '238 -> '237) -> ('239 -> '238) -> '239 -> '237) -> '240) -> '242}
T* infer (let s1 = (fn x -> (fn y -> (fn z -> (((x s) (z s)) ((y s) (z s))))))) result = unit
T* unify unit unit
T* infer s1
T* infer Ident s1
T* infer Ident s1 ... type schema is { vars:[237,238,239,233,234,235,242,241,240,224,225,226] body:((('226 -> '225 -> '224) -> ('226 -> '225) -> '226 -> '224) -> '240 -> '241 -> '242) -> ((('235 -> '234 -> '233) -> ('235 -> '234) -> '235 -> '233) -> '240 -> '241) -> ((('239 -> '238 -> '237) -> ('239 -> '238) -> '239 -> '237) -> '240) -> '242}
T* infer Ident s1 ... ts alpha = { vars:[243,244,245,246,247,248,249,250,251,252,253,254] body:((('254 -> '253 -> '252) -> ('254 -> '253) -> '254 -> '252) -> '251 -> '250 -> '249) -> ((('248 -> '247 -> '246) -> ('248 -> '247) -> '248 -> '246) -> '251 -> '250) -> ((('245 -> '244 -> '243) -> ('245 -> '244) -> '245 -> '243) -> '251) -> '249}
T* infer s1 result = ((('254 -> '253 -> '252) -> ('254 -> '253) -> '254 -> '252) -> '251 -> '250 -> '249) -> ((('248 -> '247 -> '246) -> ('248 -> '247) -> '248 -> '246) -> '251 -> '250) -> ((('245 -> '244 -> '243) -> ('245 -> '244) -> '245 -> '243) -> '251) -> '249
T* infer {(let s = (fn x -> (fn y -> (fn z -> ((x z) (y z)))))); (let s1 = (fn x -> (fn y -> (fn z -> (((x s) (z s)) ((y s) (z s))))))); s1; } result = ((('254 -> '253 -> '252) -> ('254 -> '253) -> '254 -> '252) -> '251 -> '250 -> '249) -> ((('248 -> '247 -> '246) -> ('248 -> '247) -> '248 -> '246) -> '251 -> '250) -> ((('245 -> '244 -> '243) -> ('245 -> '244) -> '245 -> '243) -> '251) -> '249
infer    > ((('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c) -> 'd -> 'e -> 'f) -> ((('g -> 'h -> 'i) -> ('g -> 'h) -> 'g -> 'i) -> 'd -> 'e) -> ((('j -> 'k -> 'l) -> ('j -> 'k) -> 'j -> 'l) -> 'd) -> 'f
expected > ((('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c) -> 'd -> 'e -> 'f) -> ((('g -> 'h -> 'i) -> ('g -> 'h) -> 'g -> 'i) -> 'd -> 'e) -> ((('j -> 'k -> 'l) -> ('j -> 'k) -> 'j -> 'l) -> 'd) -> 'f
[32m.[0mtext> { let g = fn h -> fn t -> fn f -> fn x -> f h (t f x); g }
T* infer {(let g = (fn h -> (fn t -> (fn f -> (fn x -> ((f h) ((t f) x))))))); g; }
T* infer (let g = (fn h -> (fn t -> (fn f -> (fn x -> ((f h) ((t f) x)))))))
T* infer let g = (fn h -> (fn t -> (fn f -> (fn x -> ((f h) ((t f) x))))))
T* infer (fn h -> (fn t -> (fn f -> (fn x -> ((f h) ((t f) x))))))
T* infer Fn (h, (fn t -> (fn f -> (fn x -> ((f h) ((t f) x))))))
T* infer h ... arg type = '255
T* infer h ... arg ts = { vars:[] body:'255}
T* infer (fn t -> (fn f -> (fn x -> ((f h) ((t f) x)))))
T* infer Fn (t, (fn f -> (fn x -> ((f h) ((t f) x)))))
T* infer t ... arg type = '256
T* infer t ... arg ts = { vars:[] body:'256}
T* infer (fn f -> (fn x -> ((f h) ((t f) x))))
T* infer Fn (f, (fn x -> ((f h) ((t f) x))))
T* infer f ... arg type = '257
T* infer f ... arg ts = { vars:[] body:'257}
T* infer (fn x -> ((f h) ((t f) x)))
T* infer Fn (x, ((f h) ((t f) x)))
T* infer x ... arg type = '258
T* infer x ... arg ts = { vars:[] body:'258}
T* infer ((f h) ((t f) x))
T* infer (f h)
T* infer f
T* infer Ident f
T* infer Ident f ... type schema is { vars:[] body:'257}
T* infer Ident f ... ts alpha = { vars:[] body:'257}
T* infer f result = '257
T* infer h
T* infer Ident h
T* infer Ident h ... type schema is { vars:[] body:'255}
T* infer Ident h ... ts alpha = { vars:[] body:'255}
T* infer h result = '255
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (f h) result = '259
T* infer ((t f) x)
T* infer (t f)
T* infer t
T* infer Ident t
T* infer Ident t ... type schema is { vars:[] body:'256}
T* infer Ident t ... ts alpha = { vars:[] body:'256}
T* infer t result = '256
T* infer f
T* infer Ident f
T* infer Ident f ... type schema is { vars:[] body:'255 -> '259!}
T* infer Ident f ... ts alpha = { vars:[] body:'255 -> '259}
T* infer f result = '255 -> '259
T* unify 'a ('a -> 'b) -> 'c
T* unify result 'a ... 
T* ... ('a -> 'b) -> 'c
T* infer (t f) result = '260
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'258}
T* infer Ident x ... ts alpha = { vars:[] body:'258}
T* infer x result = '258
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer ((t f) x) result = '261
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer ((f h) ((t f) x)) result = '262
T* after infer '262
T* infer (fn x -> ((f h) ((t f) x))) result = '258 -> '262
T* after infer '258 -> '262
T* infer (fn f -> (fn x -> ((f h) ((t f) x)))) result = ('255 -> '261 -> '262!)! -> '258 -> '262
T* after infer ('255 -> '261 -> '262!)! -> '258 -> '262
T* infer (fn t -> (fn f -> (fn x -> ((f h) ((t f) x))))) result = (('255 -> '261 -> '262!) -> '258 -> '261!)! -> ('255 -> '261 -> '262!)! -> '258 -> '262
T* after infer (('255 -> '261 -> '262!) -> '258 -> '261!)! -> ('255 -> '261 -> '262!)! -> '258 -> '262
T* infer (fn h -> (fn t -> (fn f -> (fn x -> ((f h) ((t f) x)))))) result = '255 -> (('255 -> '261 -> '262!) -> '258 -> '261!)! -> ('255 -> '261 -> '262!)! -> '258 -> '262
T* after infer '255 -> (('255 -> '261 -> '262!) -> '258 -> '261!)! -> ('255 -> '261 -> '262!)! -> '258 -> '262
T* poly type = { vars:[258,262,261,255] body:'255 -> (('255 -> '261 -> '262) -> '258 -> '261) -> ('255 -> '261 -> '262) -> '258 -> '262}
T* infer (let g = (fn h -> (fn t -> (fn f -> (fn x -> ((f h) ((t f) x))))))) result = unit
T* unify unit unit
T* infer g
T* infer Ident g
T* infer Ident g ... type schema is { vars:[258,262,261,255] body:'255 -> (('255 -> '261 -> '262) -> '258 -> '261) -> ('255 -> '261 -> '262) -> '258 -> '262}
T* infer Ident g ... ts alpha = { vars:[263,264,265,266] body:'266 -> (('266 -> '265 -> '264) -> '263 -> '265) -> ('266 -> '265 -> '264) -> '263 -> '264}
T* infer g result = '266 -> (('266 -> '265 -> '264) -> '263 -> '265) -> ('266 -> '265 -> '264) -> '263 -> '264
T* infer {(let g = (fn h -> (fn t -> (fn f -> (fn x -> ((f h) ((t f) x))))))); g; } result = '266 -> (('266 -> '265 -> '264) -> '263 -> '265) -> ('266 -> '265 -> '264) -> '263 -> '264
infer    > 'a -> (('a -> 'b -> 'c) -> 'd -> 'b) -> ('a -> 'b -> 'c) -> 'd -> 'c
expected > 'a -> (('a -> 'b -> 'c) -> 'd -> 'b) -> ('a -> 'b -> 'c) -> 'd -> 'c
[32m.[0mtext> { let s = fn x -> fn y -> fn z -> x z (y z); let k = fn x -> fn y -> x; let kk = fn x -> fn y -> x; s k kk }
T* infer {(let s = (fn x -> (fn y -> (fn z -> ((x z) (y z)))))); (let k = (fn x -> (fn y -> x))); (let kk = (fn x -> (fn y -> x))); ((s k) kk); }
T* infer (let s = (fn x -> (fn y -> (fn z -> ((x z) (y z))))))
T* infer let s = (fn x -> (fn y -> (fn z -> ((x z) (y z)))))
T* infer (fn x -> (fn y -> (fn z -> ((x z) (y z)))))
T* infer Fn (x, (fn y -> (fn z -> ((x z) (y z)))))
T* infer x ... arg type = '267
T* infer x ... arg ts = { vars:[] body:'267}
T* infer (fn y -> (fn z -> ((x z) (y z))))
T* infer Fn (y, (fn z -> ((x z) (y z))))
T* infer y ... arg type = '268
T* infer y ... arg ts = { vars:[] body:'268}
T* infer (fn z -> ((x z) (y z)))
T* infer Fn (z, ((x z) (y z)))
T* infer z ... arg type = '269
T* infer z ... arg ts = { vars:[] body:'269}
T* infer ((x z) (y z))
T* infer (x z)
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'267}
T* infer Ident x ... ts alpha = { vars:[] body:'267}
T* infer x result = '267
T* infer z
T* infer Ident z
T* infer Ident z ... type schema is { vars:[] body:'269}
T* infer Ident z ... ts alpha = { vars:[] body:'269}
T* infer z result = '269
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (x z) result = '270
T* infer (y z)
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:'268}
T* infer Ident y ... ts alpha = { vars:[] body:'268}
T* infer y result = '268
T* infer z
T* infer Ident z
T* infer Ident z ... type schema is { vars:[] body:'269}
T* infer Ident z ... ts alpha = { vars:[] body:'269}
T* infer z result = '269
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (y z) result = '271
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer ((x z) (y z)) result = '272
T* after infer '272
T* infer (fn z -> ((x z) (y z))) result = '269 -> '272
T* after infer '269 -> '272
T* infer (fn y -> (fn z -> ((x z) (y z)))) result = ('269 -> '271)! -> '269 -> '272
T* after infer ('269 -> '271)! -> '269 -> '272
T* infer (fn x -> (fn y -> (fn z -> ((x z) (y z))))) result = ('269 -> '271 -> '272!)! -> ('269 -> '271)! -> '269 -> '272
T* after infer ('269 -> '271 -> '272!)! -> ('269 -> '271)! -> '269 -> '272
T* poly type = { vars:[272,271,269] body:('269 -> '271 -> '272) -> ('269 -> '271) -> '269 -> '272}
T* infer (let s = (fn x -> (fn y -> (fn z -> ((x z) (y z)))))) result = unit
T* unify unit unit
T* infer (let k = (fn x -> (fn y -> x)))
T* infer let k = (fn x -> (fn y -> x))
T* infer (fn x -> (fn y -> x))
T* infer Fn (x, (fn y -> x))
T* infer x ... arg type = '273
T* infer x ... arg ts = { vars:[] body:'273}
T* infer (fn y -> x)
T* infer Fn (y, x)
T* infer y ... arg type = '274
T* infer y ... arg ts = { vars:[] body:'274}
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'273}
T* infer Ident x ... ts alpha = { vars:[] body:'273}
T* infer x result = '273
T* after infer '273
T* infer (fn y -> x) result = '274 -> '273
T* after infer '274 -> '273
T* infer (fn x -> (fn y -> x)) result = '273 -> '274 -> '273
T* after infer '273 -> '274 -> '273
T* poly type = { vars:[274,273] body:'273 -> '274 -> '273}
T* infer (let k = (fn x -> (fn y -> x))) result = unit
T* unify unit unit
T* infer (let kk = (fn x -> (fn y -> x)))
T* infer let kk = (fn x -> (fn y -> x))
T* infer (fn x -> (fn y -> x))
T* infer Fn (x, (fn y -> x))
T* infer x ... arg type = '275
T* infer x ... arg ts = { vars:[] body:'275}
T* infer (fn y -> x)
T* infer Fn (y, x)
T* infer y ... arg type = '276
T* infer y ... arg ts = { vars:[] body:'276}
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'275}
T* infer Ident x ... ts alpha = { vars:[] body:'275}
T* infer x result = '275
T* after infer '275
T* infer (fn y -> x) result = '276 -> '275
T* after infer '276 -> '275
T* infer (fn x -> (fn y -> x)) result = '275 -> '276 -> '275
T* after infer '275 -> '276 -> '275
T* poly type = { vars:[276,275] body:'275 -> '276 -> '275}
T* infer (let kk = (fn x -> (fn y -> x))) result = unit
T* unify unit unit
T* infer ((s k) kk)
T* infer (s k)
T* infer s
T* infer Ident s
T* infer Ident s ... type schema is { vars:[272,271,269] body:('269 -> '271 -> '272) -> ('269 -> '271) -> '269 -> '272}
T* infer Ident s ... ts alpha = { vars:[277,278,279] body:('279 -> '278 -> '277) -> ('279 -> '278) -> '279 -> '277}
T* infer s result = ('279 -> '278 -> '277) -> ('279 -> '278) -> '279 -> '277
T* infer k
T* infer Ident k
T* infer Ident k ... type schema is { vars:[274,273] body:'273 -> '274 -> '273}
T* infer Ident k ... ts alpha = { vars:[280,281] body:'281 -> '280 -> '281}
T* infer k result = '281 -> '280 -> '281
T* unify ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c ('a -> 'b -> 'a) -> 'c
T* unify 'a -> 'b -> 'c 'a -> 'b -> 'a
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* unify 'a -> 'b 'a -> 'b
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* unify ('a -> 'b) -> 'a -> 'a 'a
T* unify result 'a ... 
T* ... ('a -> 'b) -> 'a -> 'a
T* infer (s k) result = ('281! -> '280!) -> '281! -> '281!!
T* infer kk
T* infer Ident kk
T* infer Ident kk ... type schema is { vars:[276,275] body:'275 -> '276 -> '275}
T* infer Ident kk ... ts alpha = { vars:[283,284] body:'284 -> '283 -> '284}
T* infer kk result = '284 -> '283 -> '284
T* unify ('a -> 'b) -> 'a -> 'a ('a -> 'b -> 'a) -> 'c
T* unify ('a -> 'b) -> 'a -> 'a ('a -> 'b -> 'a) -> 'c
T* unify 'a -> 'b 'a -> 'b -> 'a
T* unify 'a 'a
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* unify 'a 'a -> 'b
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* unify 'a -> 'a 'a
T* unify result 'a ... 
T* ... 'a -> 'a
T* infer ((s k) kk) result = '284! -> '284!!
T* infer {(let s = (fn x -> (fn y -> (fn z -> ((x z) (y z)))))); (let k = (fn x -> (fn y -> x))); (let kk = (fn x -> (fn y -> x))); ((s k) kk); } result = '284! -> '284!!
infer    > 'a -> 'a
expected > 'a -> 'a
[32m.[0mtext> { let s = fn x -> fn y -> fn z -> x z (y z); let k = fn x -> fn y -> x; s k k }
T* infer {(let s = (fn x -> (fn y -> (fn z -> ((x z) (y z)))))); (let k = (fn x -> (fn y -> x))); ((s k) k); }
T* infer (let s = (fn x -> (fn y -> (fn z -> ((x z) (y z))))))
T* infer let s = (fn x -> (fn y -> (fn z -> ((x z) (y z)))))
T* infer (fn x -> (fn y -> (fn z -> ((x z) (y z)))))
T* infer Fn (x, (fn y -> (fn z -> ((x z) (y z)))))
T* infer x ... arg type = '286
T* infer x ... arg ts = { vars:[] body:'286}
T* infer (fn y -> (fn z -> ((x z) (y z))))
T* infer Fn (y, (fn z -> ((x z) (y z))))
T* infer y ... arg type = '287
T* infer y ... arg ts = { vars:[] body:'287}
T* infer (fn z -> ((x z) (y z)))
T* infer Fn (z, ((x z) (y z)))
T* infer z ... arg type = '288
T* infer z ... arg ts = { vars:[] body:'288}
T* infer ((x z) (y z))
T* infer (x z)
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'286}
T* infer Ident x ... ts alpha = { vars:[] body:'286}
T* infer x result = '286
T* infer z
T* infer Ident z
T* infer Ident z ... type schema is { vars:[] body:'288}
T* infer Ident z ... ts alpha = { vars:[] body:'288}
T* infer z result = '288
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (x z) result = '289
T* infer (y z)
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:'287}
T* infer Ident y ... ts alpha = { vars:[] body:'287}
T* infer y result = '287
T* infer z
T* infer Ident z
T* infer Ident z ... type schema is { vars:[] body:'288}
T* infer Ident z ... ts alpha = { vars:[] body:'288}
T* infer z result = '288
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (y z) result = '290
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer ((x z) (y z)) result = '291
T* after infer '291
T* infer (fn z -> ((x z) (y z))) result = '288 -> '291
T* after infer '288 -> '291
T* infer (fn y -> (fn z -> ((x z) (y z)))) result = ('288 -> '290)! -> '288 -> '291
T* after infer ('288 -> '290)! -> '288 -> '291
T* infer (fn x -> (fn y -> (fn z -> ((x z) (y z))))) result = ('288 -> '290 -> '291!)! -> ('288 -> '290)! -> '288 -> '291
T* after infer ('288 -> '290 -> '291!)! -> ('288 -> '290)! -> '288 -> '291
T* poly type = { vars:[291,290,288] body:('288 -> '290 -> '291) -> ('288 -> '290) -> '288 -> '291}
T* infer (let s = (fn x -> (fn y -> (fn z -> ((x z) (y z)))))) result = unit
T* unify unit unit
T* infer (let k = (fn x -> (fn y -> x)))
T* infer let k = (fn x -> (fn y -> x))
T* infer (fn x -> (fn y -> x))
T* infer Fn (x, (fn y -> x))
T* infer x ... arg type = '292
T* infer x ... arg ts = { vars:[] body:'292}
T* infer (fn y -> x)
T* infer Fn (y, x)
T* infer y ... arg type = '293
T* infer y ... arg ts = { vars:[] body:'293}
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'292}
T* infer Ident x ... ts alpha = { vars:[] body:'292}
T* infer x result = '292
T* after infer '292
T* infer (fn y -> x) result = '293 -> '292
T* after infer '293 -> '292
T* infer (fn x -> (fn y -> x)) result = '292 -> '293 -> '292
T* after infer '292 -> '293 -> '292
T* poly type = { vars:[293,292] body:'292 -> '293 -> '292}
T* infer (let k = (fn x -> (fn y -> x))) result = unit
T* unify unit unit
T* infer ((s k) k)
T* infer (s k)
T* infer s
T* infer Ident s
T* infer Ident s ... type schema is { vars:[291,290,288] body:('288 -> '290 -> '291) -> ('288 -> '290) -> '288 -> '291}
T* infer Ident s ... ts alpha = { vars:[294,295,296] body:('296 -> '295 -> '294) -> ('296 -> '295) -> '296 -> '294}
T* infer s result = ('296 -> '295 -> '294) -> ('296 -> '295) -> '296 -> '294
T* infer k
T* infer Ident k
T* infer Ident k ... type schema is { vars:[293,292] body:'292 -> '293 -> '292}
T* infer Ident k ... ts alpha = { vars:[297,298] body:'298 -> '297 -> '298}
T* infer k result = '298 -> '297 -> '298
T* unify ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c ('a -> 'b -> 'a) -> 'c
T* unify 'a -> 'b -> 'c 'a -> 'b -> 'a
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* unify 'a -> 'b 'a -> 'b
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* unify ('a -> 'b) -> 'a -> 'a 'a
T* unify result 'a ... 
T* ... ('a -> 'b) -> 'a -> 'a
T* infer (s k) result = ('298! -> '297!) -> '298! -> '298!!
T* infer k
T* infer Ident k
T* infer Ident k ... type schema is { vars:[293,292] body:'292 -> '293 -> '292}
T* infer Ident k ... ts alpha = { vars:[300,301] body:'301 -> '300 -> '301}
T* infer k result = '301 -> '300 -> '301
T* unify ('a -> 'b) -> 'a -> 'a ('a -> 'b -> 'a) -> 'c
T* unify ('a -> 'b) -> 'a -> 'a ('a -> 'b -> 'a) -> 'c
T* unify 'a -> 'b 'a -> 'b -> 'a
T* unify 'a 'a
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* unify 'a 'a -> 'b
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* unify 'a -> 'a 'a
T* unify result 'a ... 
T* ... 'a -> 'a
T* infer ((s k) k) result = '301! -> '301!!
T* infer {(let s = (fn x -> (fn y -> (fn z -> ((x z) (y z)))))); (let k = (fn x -> (fn y -> x))); ((s k) k); } result = '301! -> '301!!
infer    > 'a -> 'a
expected > 'a -> 'a
[32m.[0mtext> { let s = fn x -> fn y -> fn z -> x z (y z); let kk = fn x -> fn y -> y; s kk kk }
T* infer {(let s = (fn x -> (fn y -> (fn z -> ((x z) (y z)))))); (let kk = (fn x -> (fn y -> y))); ((s kk) kk); }
T* infer (let s = (fn x -> (fn y -> (fn z -> ((x z) (y z))))))
T* infer let s = (fn x -> (fn y -> (fn z -> ((x z) (y z)))))
T* infer (fn x -> (fn y -> (fn z -> ((x z) (y z)))))
T* infer Fn (x, (fn y -> (fn z -> ((x z) (y z)))))
T* infer x ... arg type = '303
T* infer x ... arg ts = { vars:[] body:'303}
T* infer (fn y -> (fn z -> ((x z) (y z))))
T* infer Fn (y, (fn z -> ((x z) (y z))))
T* infer y ... arg type = '304
T* infer y ... arg ts = { vars:[] body:'304}
T* infer (fn z -> ((x z) (y z)))
T* infer Fn (z, ((x z) (y z)))
T* infer z ... arg type = '305
T* infer z ... arg ts = { vars:[] body:'305}
T* infer ((x z) (y z))
T* infer (x z)
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'303}
T* infer Ident x ... ts alpha = { vars:[] body:'303}
T* infer x result = '303
T* infer z
T* infer Ident z
T* infer Ident z ... type schema is { vars:[] body:'305}
T* infer Ident z ... ts alpha = { vars:[] body:'305}
T* infer z result = '305
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (x z) result = '306
T* infer (y z)
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:'304}
T* infer Ident y ... ts alpha = { vars:[] body:'304}
T* infer y result = '304
T* infer z
T* infer Ident z
T* infer Ident z ... type schema is { vars:[] body:'305}
T* infer Ident z ... ts alpha = { vars:[] body:'305}
T* infer z result = '305
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (y z) result = '307
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer ((x z) (y z)) result = '308
T* after infer '308
T* infer (fn z -> ((x z) (y z))) result = '305 -> '308
T* after infer '305 -> '308
T* infer (fn y -> (fn z -> ((x z) (y z)))) result = ('305 -> '307)! -> '305 -> '308
T* after infer ('305 -> '307)! -> '305 -> '308
T* infer (fn x -> (fn y -> (fn z -> ((x z) (y z))))) result = ('305 -> '307 -> '308!)! -> ('305 -> '307)! -> '305 -> '308
T* after infer ('305 -> '307 -> '308!)! -> ('305 -> '307)! -> '305 -> '308
T* poly type = { vars:[308,307,305] body:('305 -> '307 -> '308) -> ('305 -> '307) -> '305 -> '308}
T* infer (let s = (fn x -> (fn y -> (fn z -> ((x z) (y z)))))) result = unit
T* unify unit unit
T* infer (let kk = (fn x -> (fn y -> y)))
T* infer let kk = (fn x -> (fn y -> y))
T* infer (fn x -> (fn y -> y))
T* infer Fn (x, (fn y -> y))
T* infer x ... arg type = '309
T* infer x ... arg ts = { vars:[] body:'309}
T* infer (fn y -> y)
T* infer Fn (y, y)
T* infer y ... arg type = '310
T* infer y ... arg ts = { vars:[] body:'310}
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:'310}
T* infer Ident y ... ts alpha = { vars:[] body:'310}
T* infer y result = '310
T* after infer '310
T* infer (fn y -> y) result = '310 -> '310
T* after infer '310 -> '310
T* infer (fn x -> (fn y -> y)) result = '309 -> '310 -> '310
T* after infer '309 -> '310 -> '310
T* poly type = { vars:[310,309] body:'309 -> '310 -> '310}
T* infer (let kk = (fn x -> (fn y -> y))) result = unit
T* unify unit unit
T* infer ((s kk) kk)
T* infer (s kk)
T* infer s
T* infer Ident s
T* infer Ident s ... type schema is { vars:[308,307,305] body:('305 -> '307 -> '308) -> ('305 -> '307) -> '305 -> '308}
T* infer Ident s ... ts alpha = { vars:[311,312,313] body:('313 -> '312 -> '311) -> ('313 -> '312) -> '313 -> '311}
T* infer s result = ('313 -> '312 -> '311) -> ('313 -> '312) -> '313 -> '311
T* infer kk
T* infer Ident kk
T* infer Ident kk ... type schema is { vars:[310,309] body:'309 -> '310 -> '310}
T* infer Ident kk ... ts alpha = { vars:[314,315] body:'315 -> '314 -> '314}
T* infer kk result = '315 -> '314 -> '314
T* unify ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c ('a -> 'b -> 'b) -> 'c
T* unify 'a -> 'b -> 'c 'a -> 'b -> 'b
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* unify 'a -> 'b 'a -> 'a
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* unify ('a -> 'b) -> 'a -> 'b 'a
T* unify result 'a ... 
T* ... ('a -> 'b) -> 'a -> 'b
T* infer (s kk) result = ('315! -> '314!) -> '315! -> '314!!
T* infer kk
T* infer Ident kk
T* infer Ident kk ... type schema is { vars:[310,309] body:'309 -> '310 -> '310}
T* infer Ident kk ... ts alpha = { vars:[317,318] body:'318 -> '317 -> '317}
T* infer kk result = '318 -> '317 -> '317
T* unify ('a -> 'b) -> 'a -> 'b ('a -> 'b -> 'b) -> 'c
T* unify ('a -> 'b) -> 'a -> 'b ('a -> 'b -> 'b) -> 'c
T* unify 'a -> 'b 'a -> 'b -> 'b
T* unify 'a 'a
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* unify 'a 'a -> 'a
T* unify 'a 'a -> 'a
T* unify result 'a ... 
T* ... 'a -> 'a
T* unify 'a -> 'b -> 'b 'a
T* unify result 'a ... 
T* ... 'a -> 'b -> 'b
T* infer ((s kk) kk) result = '318! -> '317 -> '317!!
T* infer {(let s = (fn x -> (fn y -> (fn z -> ((x z) (y z)))))); (let kk = (fn x -> (fn y -> y))); ((s kk) kk); } result = '318! -> '317 -> '317!!
infer    > 'a -> 'b -> 'b
expected > 'a -> 'b -> 'b
[32m.[0mtext> {let pair = fn x1 -> fn x2 -> fn y -> y x1 x2; let proj1 = fn p -> p (fn x1 -> fn x2 -> x1); let proj2 = fn p -> p (fn x1 -> fn x2 -> x2); proj1 (pair 1 100)}
T* infer {(let pair = (fn x1 -> (fn x2 -> (fn y -> ((y x1) x2))))); (let proj1 = (fn p -> (p (fn x1 -> (fn x2 -> x1))))); (let proj2 = (fn p -> (p (fn x1 -> (fn x2 -> x2))))); (proj1 ((pair 1) 100)); }
T* infer (let pair = (fn x1 -> (fn x2 -> (fn y -> ((y x1) x2)))))
T* infer let pair = (fn x1 -> (fn x2 -> (fn y -> ((y x1) x2))))
T* infer (fn x1 -> (fn x2 -> (fn y -> ((y x1) x2))))
T* infer Fn (x1, (fn x2 -> (fn y -> ((y x1) x2))))
T* infer x1 ... arg type = '320
T* infer x1 ... arg ts = { vars:[] body:'320}
T* infer (fn x2 -> (fn y -> ((y x1) x2)))
T* infer Fn (x2, (fn y -> ((y x1) x2)))
T* infer x2 ... arg type = '321
T* infer x2 ... arg ts = { vars:[] body:'321}
T* infer (fn y -> ((y x1) x2))
T* infer Fn (y, ((y x1) x2))
T* infer y ... arg type = '322
T* infer y ... arg ts = { vars:[] body:'322}
T* infer ((y x1) x2)
T* infer (y x1)
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:'322}
T* infer Ident y ... ts alpha = { vars:[] body:'322}
T* infer y result = '322
T* infer x1
T* infer Ident x1
T* infer Ident x1 ... type schema is { vars:[] body:'320}
T* infer Ident x1 ... ts alpha = { vars:[] body:'320}
T* infer x1 result = '320
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (y x1) result = '323
T* infer x2
T* infer Ident x2
T* infer Ident x2 ... type schema is { vars:[] body:'321}
T* infer Ident x2 ... ts alpha = { vars:[] body:'321}
T* infer x2 result = '321
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer ((y x1) x2) result = '324
T* after infer '324
T* infer (fn y -> ((y x1) x2)) result = ('320 -> '321 -> '324!)! -> '324
T* after infer ('320 -> '321 -> '324!)! -> '324
T* infer (fn x2 -> (fn y -> ((y x1) x2))) result = '321 -> ('320 -> '321 -> '324!)! -> '324
T* after infer '321 -> ('320 -> '321 -> '324!)! -> '324
T* infer (fn x1 -> (fn x2 -> (fn y -> ((y x1) x2)))) result = '320 -> '321 -> ('320 -> '321 -> '324!)! -> '324
T* after infer '320 -> '321 -> ('320 -> '321 -> '324!)! -> '324
T* poly type = { vars:[324,321,320] body:'320 -> '321 -> ('320 -> '321 -> '324) -> '324}
T* infer (let pair = (fn x1 -> (fn x2 -> (fn y -> ((y x1) x2))))) result = unit
T* unify unit unit
T* infer (let proj1 = (fn p -> (p (fn x1 -> (fn x2 -> x1)))))
T* infer let proj1 = (fn p -> (p (fn x1 -> (fn x2 -> x1))))
T* infer (fn p -> (p (fn x1 -> (fn x2 -> x1))))
T* infer Fn (p, (p (fn x1 -> (fn x2 -> x1))))
T* infer p ... arg type = '325
T* infer p ... arg ts = { vars:[] body:'325}
T* infer (p (fn x1 -> (fn x2 -> x1)))
T* infer p
T* infer Ident p
T* infer Ident p ... type schema is { vars:[] body:'325}
T* infer Ident p ... ts alpha = { vars:[] body:'325}
T* infer p result = '325
T* infer (fn x1 -> (fn x2 -> x1))
T* infer Fn (x1, (fn x2 -> x1))
T* infer x1 ... arg type = '326
T* infer x1 ... arg ts = { vars:[] body:'326}
T* infer (fn x2 -> x1)
T* infer Fn (x2, x1)
T* infer x2 ... arg type = '327
T* infer x2 ... arg ts = { vars:[] body:'327}
T* infer x1
T* infer Ident x1
T* infer Ident x1 ... type schema is { vars:[] body:'326}
T* infer Ident x1 ... ts alpha = { vars:[] body:'326}
T* infer x1 result = '326
T* after infer '326
T* infer (fn x2 -> x1) result = '327 -> '326
T* after infer '327 -> '326
T* infer (fn x1 -> (fn x2 -> x1)) result = '326 -> '327 -> '326
T* unify 'a ('a -> 'b -> 'a) -> 'c
T* unify result 'a ... 
T* ... ('a -> 'b -> 'a) -> 'c
T* infer (p (fn x1 -> (fn x2 -> x1))) result = '328
T* after infer '328
T* infer (fn p -> (p (fn x1 -> (fn x2 -> x1)))) result = (('326 -> '327 -> '326) -> '328)! -> '328
T* after infer (('326 -> '327 -> '326) -> '328)! -> '328
T* poly type = { vars:[328,327,326] body:(('326 -> '327 -> '326) -> '328) -> '328}
T* infer (let proj1 = (fn p -> (p (fn x1 -> (fn x2 -> x1))))) result = unit
T* unify unit unit
T* infer (let proj2 = (fn p -> (p (fn x1 -> (fn x2 -> x2)))))
T* infer let proj2 = (fn p -> (p (fn x1 -> (fn x2 -> x2))))
T* infer (fn p -> (p (fn x1 -> (fn x2 -> x2))))
T* infer Fn (p, (p (fn x1 -> (fn x2 -> x2))))
T* infer p ... arg type = '329
T* infer p ... arg ts = { vars:[] body:'329}
T* infer (p (fn x1 -> (fn x2 -> x2)))
T* infer p
T* infer Ident p
T* infer Ident p ... type schema is { vars:[] body:'329}
T* infer Ident p ... ts alpha = { vars:[] body:'329}
T* infer p result = '329
T* infer (fn x1 -> (fn x2 -> x2))
T* infer Fn (x1, (fn x2 -> x2))
T* infer x1 ... arg type = '330
T* infer x1 ... arg ts = { vars:[] body:'330}
T* infer (fn x2 -> x2)
T* infer Fn (x2, x2)
T* infer x2 ... arg type = '331
T* infer x2 ... arg ts = { vars:[] body:'331}
T* infer x2
T* infer Ident x2
T* infer Ident x2 ... type schema is { vars:[] body:'331}
T* infer Ident x2 ... ts alpha = { vars:[] body:'331}
T* infer x2 result = '331
T* after infer '331
T* infer (fn x2 -> x2) result = '331 -> '331
T* after infer '331 -> '331
T* infer (fn x1 -> (fn x2 -> x2)) result = '330 -> '331 -> '331
T* unify 'a ('a -> 'b -> 'b) -> 'c
T* unify result 'a ... 
T* ... ('a -> 'b -> 'b) -> 'c
T* infer (p (fn x1 -> (fn x2 -> x2))) result = '332
T* after infer '332
T* infer (fn p -> (p (fn x1 -> (fn x2 -> x2)))) result = (('330 -> '331 -> '331) -> '332)! -> '332
T* after infer (('330 -> '331 -> '331) -> '332)! -> '332
T* poly type = { vars:[332,331,330] body:(('330 -> '331 -> '331) -> '332) -> '332}
T* infer (let proj2 = (fn p -> (p (fn x1 -> (fn x2 -> x2))))) result = unit
T* unify unit unit
T* infer (proj1 ((pair 1) 100))
T* infer proj1
T* infer Ident proj1
T* infer Ident proj1 ... type schema is { vars:[328,327,326] body:(('326 -> '327 -> '326) -> '328) -> '328}
T* infer Ident proj1 ... ts alpha = { vars:[333,334,335] body:(('335 -> '334 -> '335) -> '333) -> '333}
T* infer proj1 result = (('335 -> '334 -> '335) -> '333) -> '333
T* infer ((pair 1) 100)
T* infer (pair 1)
T* infer pair
T* infer Ident pair
T* infer Ident pair ... type schema is { vars:[324,321,320] body:'320 -> '321 -> ('320 -> '321 -> '324) -> '324}
T* infer Ident pair ... ts alpha = { vars:[336,337,338] body:'338 -> '337 -> ('338 -> '337 -> '336) -> '336}
T* infer pair result = '338 -> '337 -> ('338 -> '337 -> '336) -> '336
T* infer 1
T* infer 1 result = int
T* unify 'a -> 'b -> ('a -> 'b -> 'c) -> 'c int -> 'a
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify 'a -> (int -> 'a -> 'b) -> 'b 'a
T* unify result 'a ... 
T* ... 'a -> (int -> 'a -> 'b) -> 'b
T* infer (pair 1) result = '337 -> (int! -> '337 -> '336) -> '336!
T* infer 100
T* infer 100 result = int
T* unify 'a -> (int -> 'a -> 'b) -> 'b int -> 'a
T* unify 'a -> (int -> 'a -> 'b) -> 'b int -> 'a
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify (int -> int -> 'a) -> 'a 'a
T* unify result 'a ... 
T* ... (int -> int -> 'a) -> 'a
T* infer ((pair 1) 100) result = (int! -> int! -> '336) -> '336!
T* unify (('a -> 'b -> 'a) -> 'c) -> 'c ((int -> int -> 'a) -> 'a) -> 'b
T* unify ('a -> 'b -> 'a) -> 'c (int -> int -> 'a) -> 'a
T* unify ('a -> 'b -> 'a) -> 'c (int -> int -> 'a) -> 'a
T* unify 'a -> 'b -> 'a int -> int -> 'a
T* unify 'a int
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify 'a -> int int -> 'a
T* unify 'a int
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify int 'a
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* unify 'a int
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify int 'a
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (proj1 ((pair 1) 100)) result = int!
T* infer {(let pair = (fn x1 -> (fn x2 -> (fn y -> ((y x1) x2))))); (let proj1 = (fn p -> (p (fn x1 -> (fn x2 -> x1))))); (let proj2 = (fn p -> (p (fn x1 -> (fn x2 -> x2))))); (proj1 ((pair 1) 100)); } result = int!
infer    > int
expected > int
[32m.[0mtext> {let pair = fn x1 -> fn x2 -> fn y -> y x1 x2; let proj1 = fn p -> p (fn x1 -> fn x2 -> x1); let proj2 = fn p -> p (fn x1 -> fn x2 -> x2); proj1 (proj2 (pair 10 (pair 20 30)))}
T* infer {(let pair = (fn x1 -> (fn x2 -> (fn y -> ((y x1) x2))))); (let proj1 = (fn p -> (p (fn x1 -> (fn x2 -> x1))))); (let proj2 = (fn p -> (p (fn x1 -> (fn x2 -> x2))))); (proj1 (proj2 ((pair 10) ((pair 20) 30)))); }
T* infer (let pair = (fn x1 -> (fn x2 -> (fn y -> ((y x1) x2)))))
T* infer let pair = (fn x1 -> (fn x2 -> (fn y -> ((y x1) x2))))
T* infer (fn x1 -> (fn x2 -> (fn y -> ((y x1) x2))))
T* infer Fn (x1, (fn x2 -> (fn y -> ((y x1) x2))))
T* infer x1 ... arg type = '342
T* infer x1 ... arg ts = { vars:[] body:'342}
T* infer (fn x2 -> (fn y -> ((y x1) x2)))
T* infer Fn (x2, (fn y -> ((y x1) x2)))
T* infer x2 ... arg type = '343
T* infer x2 ... arg ts = { vars:[] body:'343}
T* infer (fn y -> ((y x1) x2))
T* infer Fn (y, ((y x1) x2))
T* infer y ... arg type = '344
T* infer y ... arg ts = { vars:[] body:'344}
T* infer ((y x1) x2)
T* infer (y x1)
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:'344}
T* infer Ident y ... ts alpha = { vars:[] body:'344}
T* infer y result = '344
T* infer x1
T* infer Ident x1
T* infer Ident x1 ... type schema is { vars:[] body:'342}
T* infer Ident x1 ... ts alpha = { vars:[] body:'342}
T* infer x1 result = '342
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer (y x1) result = '345
T* infer x2
T* infer Ident x2
T* infer Ident x2 ... type schema is { vars:[] body:'343}
T* infer Ident x2 ... ts alpha = { vars:[] body:'343}
T* infer x2 result = '343
T* unify 'a 'a -> 'b
T* unify result 'a ... 
T* ... 'a -> 'b
T* infer ((y x1) x2) result = '346
T* after infer '346
T* infer (fn y -> ((y x1) x2)) result = ('342 -> '343 -> '346!)! -> '346
T* after infer ('342 -> '343 -> '346!)! -> '346
T* infer (fn x2 -> (fn y -> ((y x1) x2))) result = '343 -> ('342 -> '343 -> '346!)! -> '346
T* after infer '343 -> ('342 -> '343 -> '346!)! -> '346
T* infer (fn x1 -> (fn x2 -> (fn y -> ((y x1) x2)))) result = '342 -> '343 -> ('342 -> '343 -> '346!)! -> '346
T* after infer '342 -> '343 -> ('342 -> '343 -> '346!)! -> '346
T* poly type = { vars:[346,343,342] body:'342 -> '343 -> ('342 -> '343 -> '346) -> '346}
T* infer (let pair = (fn x1 -> (fn x2 -> (fn y -> ((y x1) x2))))) result = unit
T* unify unit unit
T* infer (let proj1 = (fn p -> (p (fn x1 -> (fn x2 -> x1)))))
T* infer let proj1 = (fn p -> (p (fn x1 -> (fn x2 -> x1))))
T* infer (fn p -> (p (fn x1 -> (fn x2 -> x1))))
T* infer Fn (p, (p (fn x1 -> (fn x2 -> x1))))
T* infer p ... arg type = '347
T* infer p ... arg ts = { vars:[] body:'347}
T* infer (p (fn x1 -> (fn x2 -> x1)))
T* infer p
T* infer Ident p
T* infer Ident p ... type schema is { vars:[] body:'347}
T* infer Ident p ... ts alpha = { vars:[] body:'347}
T* infer p result = '347
T* infer (fn x1 -> (fn x2 -> x1))
T* infer Fn (x1, (fn x2 -> x1))
T* infer x1 ... arg type = '348
T* infer x1 ... arg ts = { vars:[] body:'348}
T* infer (fn x2 -> x1)
T* infer Fn (x2, x1)
T* infer x2 ... arg type = '349
T* infer x2 ... arg ts = { vars:[] body:'349}
T* infer x1
T* infer Ident x1
T* infer Ident x1 ... type schema is { vars:[] body:'348}
T* infer Ident x1 ... ts alpha = { vars:[] body:'348}
T* infer x1 result = '348
T* after infer '348
T* infer (fn x2 -> x1) result = '349 -> '348
T* after infer '349 -> '348
T* infer (fn x1 -> (fn x2 -> x1)) result = '348 -> '349 -> '348
T* unify 'a ('a -> 'b -> 'a) -> 'c
T* unify result 'a ... 
T* ... ('a -> 'b -> 'a) -> 'c
T* infer (p (fn x1 -> (fn x2 -> x1))) result = '350
T* after infer '350
T* infer (fn p -> (p (fn x1 -> (fn x2 -> x1)))) result = (('348 -> '349 -> '348) -> '350)! -> '350
T* after infer (('348 -> '349 -> '348) -> '350)! -> '350
T* poly type = { vars:[350,349,348] body:(('348 -> '349 -> '348) -> '350) -> '350}
T* infer (let proj1 = (fn p -> (p (fn x1 -> (fn x2 -> x1))))) result = unit
T* unify unit unit
T* infer (let proj2 = (fn p -> (p (fn x1 -> (fn x2 -> x2)))))
T* infer let proj2 = (fn p -> (p (fn x1 -> (fn x2 -> x2))))
T* infer (fn p -> (p (fn x1 -> (fn x2 -> x2))))
T* infer Fn (p, (p (fn x1 -> (fn x2 -> x2))))
T* infer p ... arg type = '351
T* infer p ... arg ts = { vars:[] body:'351}
T* infer (p (fn x1 -> (fn x2 -> x2)))
T* infer p
T* infer Ident p
T* infer Ident p ... type schema is { vars:[] body:'351}
T* infer Ident p ... ts alpha = { vars:[] body:'351}
T* infer p result = '351
T* infer (fn x1 -> (fn x2 -> x2))
T* infer Fn (x1, (fn x2 -> x2))
T* infer x1 ... arg type = '352
T* infer x1 ... arg ts = { vars:[] body:'352}
T* infer (fn x2 -> x2)
T* infer Fn (x2, x2)
T* infer x2 ... arg type = '353
T* infer x2 ... arg ts = { vars:[] body:'353}
T* infer x2
T* infer Ident x2
T* infer Ident x2 ... type schema is { vars:[] body:'353}
T* infer Ident x2 ... ts alpha = { vars:[] body:'353}
T* infer x2 result = '353
T* after infer '353
T* infer (fn x2 -> x2) result = '353 -> '353
T* after infer '353 -> '353
T* infer (fn x1 -> (fn x2 -> x2)) result = '352 -> '353 -> '353
T* unify 'a ('a -> 'b -> 'b) -> 'c
T* unify result 'a ... 
T* ... ('a -> 'b -> 'b) -> 'c
T* infer (p (fn x1 -> (fn x2 -> x2))) result = '354
T* after infer '354
T* infer (fn p -> (p (fn x1 -> (fn x2 -> x2)))) result = (('352 -> '353 -> '353) -> '354)! -> '354
T* after infer (('352 -> '353 -> '353) -> '354)! -> '354
T* poly type = { vars:[354,353,352] body:(('352 -> '353 -> '353) -> '354) -> '354}
T* infer (let proj2 = (fn p -> (p (fn x1 -> (fn x2 -> x2))))) result = unit
T* unify unit unit
T* infer (proj1 (proj2 ((pair 10) ((pair 20) 30))))
T* infer proj1
T* infer Ident proj1
T* infer Ident proj1 ... type schema is { vars:[350,349,348] body:(('348 -> '349 -> '348) -> '350) -> '350}
T* infer Ident proj1 ... ts alpha = { vars:[355,356,357] body:(('357 -> '356 -> '357) -> '355) -> '355}
T* infer proj1 result = (('357 -> '356 -> '357) -> '355) -> '355
T* infer (proj2 ((pair 10) ((pair 20) 30)))
T* infer proj2
T* infer Ident proj2
T* infer Ident proj2 ... type schema is { vars:[354,353,352] body:(('352 -> '353 -> '353) -> '354) -> '354}
T* infer Ident proj2 ... ts alpha = { vars:[358,359,360] body:(('360 -> '359 -> '359) -> '358) -> '358}
T* infer proj2 result = (('360 -> '359 -> '359) -> '358) -> '358
T* infer ((pair 10) ((pair 20) 30))
T* infer (pair 10)
T* infer pair
T* infer Ident pair
T* infer Ident pair ... type schema is { vars:[346,343,342] body:'342 -> '343 -> ('342 -> '343 -> '346) -> '346}
T* infer Ident pair ... ts alpha = { vars:[361,362,363] body:'363 -> '362 -> ('363 -> '362 -> '361) -> '361}
T* infer pair result = '363 -> '362 -> ('363 -> '362 -> '361) -> '361
T* infer 10
T* infer 10 result = int
T* unify 'a -> 'b -> ('a -> 'b -> 'c) -> 'c int -> 'a
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify 'a -> (int -> 'a -> 'b) -> 'b 'a
T* unify result 'a ... 
T* ... 'a -> (int -> 'a -> 'b) -> 'b
T* infer (pair 10) result = '362 -> (int! -> '362 -> '361) -> '361!
T* infer ((pair 20) 30)
T* infer (pair 20)
T* infer pair
T* infer Ident pair
T* infer Ident pair ... type schema is { vars:[346,343,342] body:'342 -> '343 -> ('342 -> '343 -> '346) -> '346}
T* infer Ident pair ... ts alpha = { vars:[365,366,367] body:'367 -> '366 -> ('367 -> '366 -> '365) -> '365}
T* infer pair result = '367 -> '366 -> ('367 -> '366 -> '365) -> '365
T* infer 20
T* infer 20 result = int
T* unify 'a -> 'b -> ('a -> 'b -> 'c) -> 'c int -> 'a
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify 'a -> (int -> 'a -> 'b) -> 'b 'a
T* unify result 'a ... 
T* ... 'a -> (int -> 'a -> 'b) -> 'b
T* infer (pair 20) result = '366 -> (int! -> '366 -> '365) -> '365!
T* infer 30
T* infer 30 result = int
T* unify 'a -> (int -> 'a -> 'b) -> 'b int -> 'a
T* unify 'a -> (int -> 'a -> 'b) -> 'b int -> 'a
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify (int -> int -> 'a) -> 'a 'a
T* unify result 'a ... 
T* ... (int -> int -> 'a) -> 'a
T* infer ((pair 20) 30) result = (int! -> int! -> '365) -> '365!
T* unify 'a -> (int -> 'a -> 'b) -> 'b ((int -> int -> 'a) -> 'a) -> 'b
T* unify 'a -> (int -> 'a -> 'b) -> 'b ((int -> int -> 'a) -> 'a) -> 'b
T* unify 'a (int -> int -> 'a) -> 'a
T* unify 'a (int -> int -> 'a) -> 'a
T* unify result 'a ... 
T* ... (int -> int -> 'a) -> 'a
T* unify (int -> ((int -> int -> 'a) -> 'a) -> 'b) -> 'b 'a
T* unify result 'a ... 
T* ... (int -> ((int -> int -> 'a) -> 'a) -> 'b) -> 'b
T* infer ((pair 10) ((pair 20) 30)) result = (int! -> ((int! -> int! -> '365) -> '365)! -> '361) -> '361!
T* unify (('a -> 'b -> 'b) -> 'c) -> 'c ((int -> ((int -> int -> 'a) -> 'a) -> 'b) -> 'b) -> 'c
T* unify ('a -> 'b -> 'b) -> 'c (int -> ((int -> int -> 'a) -> 'a) -> 'b) -> 'b
T* unify ('a -> 'b -> 'b) -> 'c (int -> ((int -> int -> 'a) -> 'a) -> 'b) -> 'b
T* unify 'a -> 'b -> 'b int -> ((int -> int -> 'a) -> 'a) -> 'b
T* unify 'a int
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify 'a -> 'a ((int -> int -> 'a) -> 'a) -> 'b
T* unify 'a (int -> int -> 'a) -> 'a
T* unify 'a (int -> int -> 'a) -> 'a
T* unify result 'a ... 
T* ... (int -> int -> 'a) -> 'a
T* unify (int -> int -> 'a) -> 'a 'a
T* unify (int -> int -> 'a) -> 'a 'a
T* unify result 'a ... 
T* ... (int -> int -> 'a) -> 'a
T* unify 'a (int -> int -> 'a) -> 'a
T* unify 'a (int -> int -> 'a) -> 'a
T* unify result 'a ... 
T* ... (int -> int -> 'a) -> 'a
T* unify (int -> int -> 'a) -> 'a 'a
T* unify (int -> int -> 'a) -> 'a 'a
T* unify result 'a ... 
T* ... (int -> int -> 'a) -> 'a
T* infer (proj2 ((pair 10) ((pair 20) 30))) result = (int! -> int! -> '365) -> '365!
T* unify (('a -> 'b -> 'a) -> 'c) -> 'c ((int -> int -> 'a) -> 'a) -> 'b
T* unify ('a -> 'b -> 'a) -> 'c (int -> int -> 'a) -> 'a
T* unify ('a -> 'b -> 'a) -> 'c (int -> int -> 'a) -> 'a
T* unify 'a -> 'b -> 'a int -> int -> 'a
T* unify 'a int
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify 'a -> int int -> 'a
T* unify 'a int
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify int 'a
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* unify 'a int
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify int 'a
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (proj1 (proj2 ((pair 10) ((pair 20) 30)))) result = int!
T* infer {(let pair = (fn x1 -> (fn x2 -> (fn y -> ((y x1) x2))))); (let proj1 = (fn p -> (p (fn x1 -> (fn x2 -> x1))))); (let proj2 = (fn p -> (p (fn x1 -> (fn x2 -> x2))))); (proj1 (proj2 ((pair 10) ((pair 20) 30)))); } result = int!
infer    > int
expected > int
[32m.[0mtext> {let f = fn x -> x; if f true then f 1 else f 2}
T* infer {(let f = (fn x -> x)); (if (f true) then (f 1) else (f 2)); }
T* infer (let f = (fn x -> x))
T* infer let f = (fn x -> x)
T* infer (fn x -> x)
T* infer Fn (x, x)
T* infer x ... arg type = '373
T* infer x ... arg ts = { vars:[] body:'373}
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'373}
T* infer Ident x ... ts alpha = { vars:[] body:'373}
T* infer x result = '373
T* after infer '373
T* infer (fn x -> x) result = '373 -> '373
T* after infer '373 -> '373
T* poly type = { vars:[373] body:'373 -> '373}
T* infer (let f = (fn x -> x)) result = unit
T* unify unit unit
T* infer (if (f true) then (f 1) else (f 2))
T* infer If (f true) then (f 1) else (f 2)
T* infer (f true)
T* infer f
T* infer Ident f
T* infer Ident f ... type schema is { vars:[373] body:'373 -> '373}
T* infer Ident f ... ts alpha = { vars:[374] body:'374 -> '374}
T* infer f result = '374 -> '374
T* infer true
T* infer true result = bool
T* unify 'a -> 'a bool -> 'a
T* unify 'a bool
T* unify result 'a ... 
T* ... bool
T* unify bool 'a
T* unify bool 'a
T* unify result 'a ... 
T* ... bool
T* infer (f true) result = bool!
T* unify bool bool
T* unify bool bool
T* infer (f 1)
T* infer f
T* infer Ident f
T* infer Ident f ... type schema is { vars:[373] body:'373 -> '373}
T* infer Ident f ... ts alpha = { vars:[376] body:'376 -> '376}
T* infer f result = '376 -> '376
T* infer 1
T* infer 1 result = int
T* unify 'a -> 'a int -> 'a
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify int 'a
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (f 1) result = int!
T* infer (f 2)
T* infer f
T* infer Ident f
T* infer Ident f ... type schema is { vars:[373] body:'373 -> '373}
T* infer Ident f ... ts alpha = { vars:[378] body:'378 -> '378}
T* infer f result = '378 -> '378
T* infer 2
T* infer 2 result = int
T* unify 'a -> 'a int -> 'a
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify int 'a
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (f 2) result = int!
T* unify int int
T* unify int int
T* unify int int
T* infer (if (f true) then (f 1) else (f 2)) result = int!
T* infer {(let f = (fn x -> x)); (if (f true) then (f 1) else (f 2)); } result = int!
infer    > int
expected > int
[32m.[0mtext> {let f = fn x -> 3; f true + f 4}
T* infer {(let f = (fn x -> 3)); ((f true) + (f 4)); }
T* infer (let f = (fn x -> 3))
T* infer let f = (fn x -> 3)
T* infer (fn x -> 3)
T* infer Fn (x, 3)
T* infer x ... arg type = '380
T* infer x ... arg ts = { vars:[] body:'380}
T* infer 3
T* infer 3 result = int
T* after infer int
T* infer (fn x -> 3) result = '380 -> int
T* after infer '380 -> int
T* poly type = { vars:[380] body:'380 -> int}
T* infer (let f = (fn x -> 3)) result = unit
T* unify unit unit
T* infer ((f true) + (f 4))
T* infer (f true)
T* infer f
T* infer Ident f
T* infer Ident f ... type schema is { vars:[380] body:'380 -> int}
T* infer Ident f ... ts alpha = { vars:[381] body:'381 -> int}
T* infer f result = '381 -> int
T* infer true
T* infer true result = bool
T* unify 'a -> int bool -> 'a
T* unify 'a bool
T* unify result 'a ... 
T* ... bool
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (f true) result = int!
T* infer (f 4)
T* infer f
T* infer Ident f
T* infer Ident f ... type schema is { vars:[380] body:'380 -> int}
T* infer Ident f ... ts alpha = { vars:[383] body:'383 -> int}
T* infer f result = '383 -> int
T* infer 4
T* infer 4 result = int
T* unify 'a -> int int -> 'a
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer (f 4) result = int!
T* infer_binary + int int
T* unify int int
T* unify int int
T* unify int int
T* after unify int int
T* infer ((f true) + (f 4)) result = int!
T* infer {(let f = (fn x -> 3)); ((f true) + (f 4)); } result = int!
infer    > int
expected > int
[32m.[0mtext> fn b -> {let f = fn x -> x; let g = fn y -> y; if b then f g else g f}
T* infer (fn b -> {(let f = (fn x -> x)); (let g = (fn y -> y)); (if b then (f g) else (g f)); })
T* infer Fn (b, {(let f = (fn x -> x)); (let g = (fn y -> y)); (if b then (f g) else (g f)); })
T* infer b ... arg type = '385
T* infer b ... arg ts = { vars:[] body:'385}
T* infer {(let f = (fn x -> x)); (let g = (fn y -> y)); (if b then (f g) else (g f)); }
T* infer (let f = (fn x -> x))
T* infer let f = (fn x -> x)
T* infer (fn x -> x)
T* infer Fn (x, x)
T* infer x ... arg type = '386
T* infer x ... arg ts = { vars:[] body:'386}
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'386}
T* infer Ident x ... ts alpha = { vars:[] body:'386}
T* infer x result = '386
T* after infer '386
T* infer (fn x -> x) result = '386 -> '386
T* after infer '386 -> '386
T* poly type = { vars:[386] body:'386 -> '386}
T* infer (let f = (fn x -> x)) result = unit
T* unify unit unit
T* infer (let g = (fn y -> y))
T* infer let g = (fn y -> y)
T* infer (fn y -> y)
T* infer Fn (y, y)
T* infer y ... arg type = '387
T* infer y ... arg ts = { vars:[] body:'387}
T* infer y
T* infer Ident y
T* infer Ident y ... type schema is { vars:[] body:'387}
T* infer Ident y ... ts alpha = { vars:[] body:'387}
T* infer y result = '387
T* after infer '387
T* infer (fn y -> y) result = '387 -> '387
T* after infer '387 -> '387
T* poly type = { vars:[387] body:'387 -> '387}
T* infer (let g = (fn y -> y)) result = unit
T* unify unit unit
T* infer (if b then (f g) else (g f))
T* infer If b then (f g) else (g f)
T* infer b
T* infer Ident b
T* infer Ident b ... type schema is { vars:[] body:'385}
T* infer Ident b ... ts alpha = { vars:[] body:'385}
T* infer b result = '385
T* unify bool 'a
T* unify result 'a ... 
T* ... bool
T* infer (f g)
T* infer f
T* infer Ident f
T* infer Ident f ... type schema is { vars:[386] body:'386 -> '386}
T* infer Ident f ... ts alpha = { vars:[388] body:'388 -> '388}
T* infer f result = '388 -> '388
T* infer g
T* infer Ident g
T* infer Ident g ... type schema is { vars:[387] body:'387 -> '387}
T* infer Ident g ... ts alpha = { vars:[389] body:'389 -> '389}
T* infer g result = '389 -> '389
T* unify 'a -> 'a ('a -> 'a) -> 'b
T* unify 'a 'a -> 'a
T* unify result 'a ... 
T* ... 'a -> 'a
T* unify 'a -> 'a 'a
T* unify 'a -> 'a 'a
T* unify result 'a ... 
T* ... 'a -> 'a
T* infer (f g) result = '389 -> '389!
T* infer (g f)
T* infer g
T* infer Ident g
T* infer Ident g ... type schema is { vars:[387] body:'387 -> '387}
T* infer Ident g ... ts alpha = { vars:[391] body:'391 -> '391}
T* infer g result = '391 -> '391
T* infer f
T* infer Ident f
T* infer Ident f ... type schema is { vars:[386] body:'386 -> '386}
T* infer Ident f ... ts alpha = { vars:[392] body:'392 -> '392}
T* infer f result = '392 -> '392
T* unify 'a -> 'a ('a -> 'a) -> 'b
T* unify 'a 'a -> 'a
T* unify result 'a ... 
T* ... 'a -> 'a
T* unify 'a -> 'a 'a
T* unify 'a -> 'a 'a
T* unify result 'a ... 
T* ... 'a -> 'a
T* infer (g f) result = '392 -> '392!
T* unify 'a -> 'a 'a -> 'a
T* unify 'a -> 'a 'a -> 'a
T* unify 'a -> 'a 'a -> 'a
T* unify 'a 'a
T* unify result 'a ... 
T* ... 'a
T* unify 'a 'a
T* unify 'a 'a
T* infer (if b then (f g) else (g f)) result = '392! -> '392!!
T* infer {(let f = (fn x -> x)); (let g = (fn y -> y)); (if b then (f g) else (g f)); } result = '392! -> '392!!
T* after infer '392! -> '392!!
T* infer (fn b -> {(let f = (fn x -> x)); (let g = (fn y -> y)); (if b then (f g) else (g f)); }) result = bool! -> '392! -> '392!!
infer    > bool -> 'a -> 'a
expected > bool -> 'a -> 'a
[32m.[0mtext> fn x -> match x { [] -> 0 | _ -> 1}
T* infer (fn x -> (match x { | [] -> 0 | _ -> 1}))
T* infer Fn (x, (match x { | [] -> 0 | _ -> 1}))
T* infer x ... arg type = '394
T* infer x ... arg ts = { vars:[] body:'394}
T* infer (match x { | [] -> 0 | _ -> 1})
T* infer_match x
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'394}
T* infer Ident x ... ts alpha = { vars:[] body:'394}
T* infer x result = '394
T* after infer 'a
T* pat_list .. (pat,expr)::rest
T* unify_pat ([], 'a)
T* unify_pat (pat, TVar (_, {contents = None}))
T* pattern_to_type []
T* unify ['a] 'a
T* unify result 'a ... 
T* ... ['a]
T* infer 0
T* infer 0 result = int
T* unify_pat (_, ['a])
T* infer 1
T* infer 1 result = int
T* unify int int
T* infer (match x { | [] -> 0 | _ -> 1}) result = int
T* after infer int
T* infer (fn x -> (match x { | [] -> 0 | _ -> 1})) result = ['395]! -> int
infer    > ['a] -> int
expected > ['a] -> int
[32m.[0mtext> fn x -> match x { true -> 0 | _ -> 2}
T* infer (fn x -> (match x { | true -> 0 | _ -> 2}))
T* infer Fn (x, (match x { | true -> 0 | _ -> 2}))
T* infer x ... arg type = '396
T* infer x ... arg ts = { vars:[] body:'396}
T* infer (match x { | true -> 0 | _ -> 2})
T* infer_match x
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'396}
T* infer Ident x ... ts alpha = { vars:[] body:'396}
T* infer x result = '396
T* after infer 'a
T* pat_list .. (pat,expr)::rest
T* unify_pat (true, 'a)
T* unify_pat (pat, TVar (_, {contents = None}))
T* pattern_to_type true
T* unify bool 'a
T* unify result 'a ... 
T* ... bool
T* infer 0
T* infer 0 result = int
T* unify_pat (_, bool)
T* infer 2
T* infer 2 result = int
T* unify int int
T* infer (match x { | true -> 0 | _ -> 2}) result = int
T* after infer int
T* infer (fn x -> (match x { | true -> 0 | _ -> 2})) result = bool! -> int
infer    > bool -> int
expected > bool -> int
[32m.[0mtext> fn x -> match x { "abc" -> 0 | _ -> 2}
T* infer (fn x -> (match x { | "abc" -> 0 | _ -> 2}))
T* infer Fn (x, (match x { | "abc" -> 0 | _ -> 2}))
T* infer x ... arg type = '397
T* infer x ... arg ts = { vars:[] body:'397}
T* infer (match x { | "abc" -> 0 | _ -> 2})
T* infer_match x
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'397}
T* infer Ident x ... ts alpha = { vars:[] body:'397}
T* infer x result = '397
T* after infer 'a
T* pat_list .. (pat,expr)::rest
T* unify_pat ("abc", 'a)
T* unify_pat (pat, TVar (_, {contents = None}))
T* pattern_to_type "abc"
T* unify string 'a
T* unify result 'a ... 
T* ... string
T* infer 0
T* infer 0 result = int
T* unify_pat (_, string)
T* infer 2
T* infer 2 result = int
T* unify int int
T* infer (match x { | "abc" -> 0 | _ -> 2}) result = int
T* after infer int
T* infer (fn x -> (match x { | "abc" -> 0 | _ -> 2})) result = string! -> int
infer    > string -> int
expected > string -> int
[32m.[0mtext> fn x -> match x { x -> x+1 }
T* infer (fn x -> (match x { | x -> (x + 1)}))
T* infer Fn (x, (match x { | x -> (x + 1)}))
T* infer x ... arg type = '398
T* infer x ... arg ts = { vars:[] body:'398}
T* infer (match x { | x -> (x + 1)})
T* infer_match x
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'398}
T* infer Ident x ... ts alpha = { vars:[] body:'398}
T* infer x result = '398
T* after infer 'a
T* pat_list .. [(pat,expr)]
T* unify_pat (x, 'a)
T* infer (x + 1)
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'398}
T* infer Ident x ... ts alpha = { vars:[] body:'398}
T* infer x result = '398
T* infer 1
T* infer 1 result = int
T* infer_binary + 'a int
T* unify 'a int
T* unify result 'a ... 
T* ... int
T* after unify int int
T* infer (x + 1) result = int!
T* infer (match x { | x -> (x + 1)}) result = int!
T* after infer int!
T* infer (fn x -> (match x { | x -> (x + 1)})) result = int! -> int!
infer    > int -> int
expected > int -> int
[32m.[0mtext> fn x -> match x { x -> x }
T* infer (fn x -> (match x { | x -> x}))
T* infer Fn (x, (match x { | x -> x}))
T* infer x ... arg type = '399
T* infer x ... arg ts = { vars:[] body:'399}
T* infer (match x { | x -> x})
T* infer_match x
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'399}
T* infer Ident x ... ts alpha = { vars:[] body:'399}
T* infer x result = '399
T* after infer 'a
T* pat_list .. [(pat,expr)]
T* unify_pat (x, 'a)
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'399}
T* infer Ident x ... ts alpha = { vars:[] body:'399}
T* infer x result = '399
T* infer (match x { | x -> x}) result = '399
T* after infer '399
T* infer (fn x -> (match x { | x -> x})) result = '399 -> '399
infer    > 'a -> 'a
expected > 'a -> 'a
[32m.[0mtext> fn x -> match x { (a,b) -> a }
T* infer (fn x -> (match x { |  a b -> a}))
T* infer Fn (x, (match x { |  a b -> a}))
T* infer x ... arg type = '400
T* infer x ... arg ts = { vars:[] body:'400}
T* infer (match x { |  a b -> a})
T* infer_match x
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'400}
T* infer Ident x ... ts alpha = { vars:[] body:'400}
T* infer x result = '400
T* after infer 'a
T* pat_list .. [(pat,expr)]
T* unify_pat ( a b, 'a)
T* unify_pat (pat, TVar (_, {contents = None}))
T* pattern_to_type  a b
T* pattern_to_type a
T* pattern_to_type b
T* unify ('a, 'b) 'a
T* unify result 'a ... 
T* ... ('a, 'b)
T* infer a
T* infer Ident a
T* infer Ident a ... type schema is { vars:[] body:'401}
T* infer Ident a ... ts alpha = { vars:[] body:'401}
T* infer a result = '401
T* infer (match x { |  a b -> a}) result = '401
T* after infer '401
T* infer (fn x -> (match x { |  a b -> a})) result = ('401, '402)! -> '401
infer    > ('a, 'b) -> 'a
expected > ('a, 'b) -> 'a
[32m.[0mtext> fn x -> match x { (a,b) -> b }
T* infer (fn x -> (match x { |  a b -> b}))
T* infer Fn (x, (match x { |  a b -> b}))
T* infer x ... arg type = '403
T* infer x ... arg ts = { vars:[] body:'403}
T* infer (match x { |  a b -> b})
T* infer_match x
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'403}
T* infer Ident x ... ts alpha = { vars:[] body:'403}
T* infer x result = '403
T* after infer 'a
T* pat_list .. [(pat,expr)]
T* unify_pat ( a b, 'a)
T* unify_pat (pat, TVar (_, {contents = None}))
T* pattern_to_type  a b
T* pattern_to_type a
T* pattern_to_type b
T* unify ('a, 'b) 'a
T* unify result 'a ... 
T* ... ('a, 'b)
T* infer b
T* infer Ident b
T* infer Ident b ... type schema is { vars:[] body:'405}
T* infer Ident b ... ts alpha = { vars:[] body:'405}
T* infer b result = '405
T* infer (match x { |  a b -> b}) result = '405
T* after infer '405
T* infer (fn x -> (match x { |  a b -> b})) result = ('404, '405)! -> '405
infer    > ('a, 'b) -> 'b
expected > ('a, 'b) -> 'b
[32m.[0mtext> fn x -> match x { [1] -> 0 }
T* infer (fn x -> (match x { | [ 1] -> 0}))
T* infer Fn (x, (match x { | [ 1] -> 0}))
T* infer x ... arg type = '406
T* infer x ... arg ts = { vars:[] body:'406}
T* infer (match x { | [ 1] -> 0})
T* infer_match x
T* infer x
T* infer Ident x
T* infer Ident x ... type schema is { vars:[] body:'406}
T* infer Ident x ... ts alpha = { vars:[] body:'406}
T* infer x result = '406
T* after infer 'a
T* pat_list .. [(pat,expr)]
T* unify_pat ([ 1], 'a)
T* unify_pat (PatList (x::xs), t)
T* pattern_to_type 1
T* unify int 'a
T* unify result 'a ... 
T* ... int
T* infer 0
T* infer 0 result = int
T* infer (match x { | [ 1] -> 0}) result = int
T* after infer int
T* infer (fn x -> (match x { | [ 1] -> 0})) result = int! -> int
infer    > int -> int
expected > [int] -> int
[31m![0mresult:int -> int != [int] -> int


All   : 274
OK    : [32m269[0m
Failed: [31m5[0m
